<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://notiz.dev</id>
    <title>notiz.dev</title>
    <updated>2026-02-24T12:21:18.505Z</updated>
    <generator>Weeklyish Articles about Web Development</generator>
    <link rel="alternate" href="https://notiz.dev"/>
    <link rel="self" href="https://notiz.dev/feed.atom"/>
    <subtitle>Weeklyish Articles about Web Development</subtitle>
    <logo>https://notiz.dev/assets/img/featured.png</logo>
    <icon>https://notiz.dev/favicon.png</icon>
    <rights>2020 notiz.dev</rights>
    <category term="Web Development"/>
    <category term="Blog"/>
    <category term="Angular"/>
    <category term="node"/>
    <entry>
        <title type="html"><![CDATA[Codegen REST API types and requests for Angular]]></title>
        <id>/blog/angular-nest-openapi-codegen</id>
        <link href="https://notiz.dev/blog/angular-nest-openapi-codegen"/>
        <updated>2022-10-17T15:00:00.000Z</updated>
        <summary type="html"><![CDATA[Automatic code generation from OpenAPI 3 for Angular]]></summary>
        <content type="html"><![CDATA[<p>Are you using a REST API in your Angular app to fetch data from a server? Are you manually adding model types, specifying each REST call with <code>HttpClient</code>? Stop right there!</p>
<p>Use <a href="https://github.com/cyclosproject/ng-openapi-gen">ng-openapi-gen</a> for a hassle free and automatic generation of models and services based on your OpenAPI 3 specification.</p>
<div shortcode="repo" repo="notiz-dev/codegen-angular-nest"></div>
<h2 id="nxmonorepo">Nx monorepo</h2>
<p>Setup a monorepo using <a href="https://nx.dev/">nx</a> with Angular and NestJS.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npx create-nx-workspace --preset angular-nest
</code></pre>

</div>
<p>Open <code>package.json</code> and replace the <code>start</code> script with:</p>
<div shortcode="code" tabs="package.json">
<pre><code class="json language-json">"start": "nx run-many --target=serve",
</code></pre>

</div>
<p>This will start both your Angular and NestJS app in serve mode.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run start
</code></pre>

</div>
<p>Angular will be exposed on <a href="http://localhost:4200">localhost:4200</a> and Nest on <a href="http://localhost:3333">localhost:3333</a>.</p>
<h2 id="setupswagger">Setup Swagger</h2>
<p>Setup Swagger in NestJS for type-safe REST endpoints.</p>
<p>First, install the Nest swagger library.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm install --save @nestjs/swagger
</code></pre>

</div>
<p>Configure Swagger in your <code>main.ts</code> file:</p>
<div shortcode="code" tabs="main.ts">
<pre><code class="ts language-ts">/**
 * This is not a production server yet!
 * This is only a minimal backend to get started.
 */

import { Logger } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

import { AppModule } from './app/app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const globalPrefix = 'api';
  app.setGlobalPrefix(globalPrefix);

  // setup swagger
  const config = new DocumentBuilder()
    .setTitle('Angular NestJS Codegen')
    .setDescription('Base for codegen for Angular app')
    .setVersion('1.0')
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  // enable cors for Angular
  app.enableCors();

  const port = process.env.PORT || 3333;
  await app.listen(port);
  Logger.log(
    `üöÄ Application is running on: http://localhost:${port}/${globalPrefix}`
  );
}

bootstrap();
</code></pre>

</div>
<p>Visit <a href="http://localhost:3333/api">localhost:3333/api</a> to see the Swagger UI.</p>
<p>While you are add it. Create a <code>message.entity.ts</code> class and annotate the attribute with <code>@ApiProperty()</code>.</p>
<div shortcode="code" tabs="message.entity.ts">
<pre><code class="ts language-ts">// entities/message.entity.ts
import { ApiProperty } from '@nestjs/swagger';

export class Message {
  @ApiProperty()
  message: string;
}
</code></pre>

</div>
<p>Use <code>@ApiResponse({ type: Message })</code> to inform Swagger about the response type.</p>
<div shortcode="code" tabs="app.controller.ts">
<pre><code class="ts language-ts">// app.controller.ts
import { Controller, Get } from '@nestjs/common';
import { ApiResponse } from '@nestjs/swagger';

import { AppService } from './app.service';
import { Message } from './entities/message.entity';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('hello')
  @ApiResponse({ type: Message })
  getData(): Message {
    return this.appService.getData();
  }
}
</code></pre>

</div>
<h2 id="configurecodegen">Configure Codegen</h2>
<p>Next, you will configure <a href="https://github.com/cyclosproject/ng-openapi-gen">ng-openapi-gen</a> as the OpenAPI 3 code generator for Angular.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm i -D ng-openapi-gen
</code></pre>

</div>
<p>Add a config file with the name <code>ng-openapi-gen.json</code> to the root folder. <code>ng-openapi-gen</code> loads the config file with this name automatically. Pass <code>ng-openapi-gen --config your-config.json</code> for an alternative config file name.</p>
<p>Copy the following config content into the file, will explain the configuration options next.</p>
<div shortcode="code" tabs="ng-openapi-gen.json">
<pre><code class="json language-json">{
  "$schema": "node_modules/ng-openapi-gen/ng-openapi-gen-schema.json",
  "input": "http://localhost:3333/api-json",
  "output": "apps/app/src/api"
}
</code></pre>

</div>
<p>With <code>$schema</code> you get autocomplete in JSON for all possible configuration <a href="https://raw.githubusercontent.com/cyclosproject/ng-openapi-gen/master/ng-openapi-gen-schema.json">options</a> of <code>ng-openapi-gen</code>. </p>
<p>The <code>input</code> requires a file or URL of a OpenAPI 3 specification. In your case the Swagger JSON is available at <a href="http://localhost:3333/api-json">localhost:3333/api-json</a>. You should see <code>openapi</code> as first value with version <code>3.0.0</code>.</p>
<p><code>output</code> is the directory for the generated files. The files are generated inside your Angular app. Change the directory if you choose a different app name (<code>apps/your-name/src/api</code>) or perhaps you want to generate into a shared library (<code>libs/api/src/lib</code>).</p>
<p>Last step, add a new script to your <code>package.json</code> let's call it <code>"codegen": "ng-openapi-gen"</code>. Run the new script, also make sure the Nest app is serving.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run codegen
</code></pre>

</div>
<p>Your output directory (<code>apps/your-name/src/api</code>) now contains a couple of new files. Next, you will start with the configuration of the REST API endpoint.</p>
<div shortcode="figure" caption="Codegen CLI Output">

![Codegen CLI Output](assets/img/blog/angular-nest-openapi-codegen/optimized/codegen-cli-output.png)

</div>
<div shortcode="figure" caption="Codegen file structure">

![Codegen file structure](assets/img/blog/angular-nest-openapi-codegen/optimized/codegen-files.png)

</div>
<h2 id="specifyapiurlwithapimodule">Specify API url with ApiModule</h2>
<p>Add <code>ApiModule</code>, import from <code>apps/your-name/src/api/api.module.ts</code>, to your Angular <code>AppModule</code> imports. Use <code>forRoot(...)</code> to specify the <code>rootUrl</code> pointing to <a href="http://localhost:3333">localhost:3333</a> in development. </p>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="ts language-ts">import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { NxWelcomeComponent } from './nx-welcome.component';
import { HttpClientModule } from '@angular/common/http';

import { ApiModule } from '../api/api.module';
import { environment } from '../environments/environment';

@NgModule({
  declarations: [AppComponent, NxWelcomeComponent],
  imports: [
    BrowserModule,
    HttpClientModule,
    ApiModule.forRoot({ rootUrl: environment.apiUrl }),
  ],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
</code></pre>

</div>
<p>Because your API endpoint will be different in production you need to add the <code>apiUrl</code> to the <code>environment(.prod).ts</code> files.</p>
<div shortcode="code" tabs="environment(.prod).ts">
<pre><code class="ts language-ts">// environments/environment.ts
export const environment = {
  production: false,
  apiUrl: 'http://localhost:3333',
};

// environments/environment.prod.ts
export const environment = {
  production: true,
  apiUrl: 'https://api.awesome-app', // update in production
};
</code></pre>

</div>
<h2 id="firstgeneratedrestrequest">First generated REST request</h2>
<p>Lastly, you'll be making a REST request with the generated API. Look into the <code>api/services</code> directory. A service will be generated for each <a href="https://docs.nestjs.com/openapi/operations#tags">tag</a> (e.g. <code>@ApiTags('users')</code>) in your Swagger API.</p>
<p>Use <code>ApiService</code> in <code>AppComponent</code> to replace the direct <code>HttpClient</code> call. Under the hood <code>ApiService</code> uses <code>HttpClient</code>.</p>
<div shortcode="code" tabs="app.component.ts">
<pre><code class="diff-ts language-diff-ts">import { Component } from '@angular/core';
-import { HttpClient } from '@angular/common/http';
-import { Message } from '@angular-nest-codegen/api-interfaces';
+import { ApiService } from '../api/services';

@Component({
  selector: 'angular-nest-codegen-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss'],
})
export class AppComponent {
+ hello$ = this.apiService.appControllerGetData();
- hello$ = this.http.get&lt;Message&gt;('/api/hello');
+ constructor(private apiService: ApiService) {}
- constructor(private http: HttpClient) {}
}
</code></pre>

</div>
<p>Perfect, you made it till the end. Keep in mind that the codegen is only as good as your <strong>Swagger documentation</strong>. If you are missing type information for the request or response, you're also missing out in codegen.</p>
<p>Checkout the following two posts as inspiration about type-safe endpoints with Nest.</p>
<div shortcode="article" routes="/blog/type-safe-file-uploads"></div>
<p><div shortcode="article" routes="/blog/type-safe-file-downloads">&lt;/div</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Downloading files with NestJS]]></title>
        <id>/blog/type-safe-file-downloads</id>
        <link href="https://notiz.dev/blog/type-safe-file-downloads"/>
        <updated>2022-07-27T10:00:00.000Z</updated>
        <summary type="html"><![CDATA[Setup type-safe endpoints for downloading files in your NestJS application.]]></summary>
        <content type="html"><![CDATA[<p>You got <a href="https://notiz.dev/blog/type-safe-file-uploads">file upload</a> figured out in your NestJS application? And now you need to <a href="https://docs.nestjs.com/techniques/streaming-files">download files</a> from your REST API? ü§ì</p>
<p>Glad you're here now, but make sure you prepare your Nest app with Swagger first.</p>
<div shortcode="article" routes="/blog/openapi-in-nestjs"></div>
<p>Want to jump directly to the code? Here is the repository.</p>
<div shortcode="repo" repo="notiz-dev/nestjs-swagger"></div>
<h2 id="filedownload">File download</h2>
<p>Downloading a file with Nest depends on how you retrieve it from your file storage:</p>
<ul>
<li>as <code>Buffer</code> use <code>response.send(fileBuffer)</code></li>
<li>as <code>Stream</code> use <code>fileStream.pipe(response)</code></li>
</ul>
<p>This will get the job done easily but you'll loose access to the response during <a href="https://docs.nestjs.com/interceptors#response-mapping">response interceptors</a>. See the <code>LoggingInterceptor</code> as an example as interceptor.</p>
<p>As an alternative, Nest provides <code>StreamableFile</code>, which solves the response interceptor problem, and supports both <code>Buffer</code> and <code>Stream</code> in one swoop. ü¶æ</p>
<div shortcode="code" tabs="download.controller.ts,download.service.ts,logging.interceptor.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Get,
  Res,
  StreamableFile,
  UseInterceptors,
} from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { DownloadService } from './download.service';
import { Response } from 'express';
import { LoggingInterceptor } from 'src/logging.interceptor';

@UseInterceptors(LoggingInterceptor)
@Controller('download')
@ApiTags('download')
export class DownloadController {
  constructor(private readonly downloadService: DownloadService) {}

  @Get('buffer')
  buffer(@Res() response: Response) {
    const file = this.downloadService.imageBuffer();
    response.send(file);
  }

  @Get('stream')
  stream(@Res() response: Response) {
    const file = this.downloadService.imageStream();
    file.pipe(response);
  }

  @Get('streamable')
  streamable(@Res({ passthrough: true }) response: Response) {
    const file = this.downloadService.fileStream();
    // or
    // const file = this.downloadService.fileBuffer();
    return new StreamableFile(file); // üëà supports Buffer and Stream
  }
}
</code></pre><pre><code class="ts language-ts">import { Injectable } from '@nestjs/common';
import { createReadStream, readFileSync } from 'fs';
import { join } from 'path';

/**
 * This service would probably download files from a file storage
 * like S3, minio etc.
 */
@Injectable()
export class DownloadService {
  constructor() {
    // create connection to your file storage
  }

  imageBuffer() {
    return readFileSync(join(process.cwd(), 'notiz.png'));
  }

  imageStream() {
    return createReadStream(join(process.cwd(), 'notiz.png'));
  }

  fileBuffer() {
    return readFileSync(join(process.cwd(), 'package.json'));
  }

  fileStream() {
    return createReadStream(join(process.cwd(), 'package.json'));
  }
}
</code></pre><pre><code class="ts language-ts">import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; {
    console.log('Before...');

    const now = Date.now();
    return next.handle().pipe(
      tap(() =&gt; console.log(`After... ${Date.now() - now}ms`)),
      tap((response) =&gt; console.log(response)), // üëà response is defined only when StreamableFile is used
    );
  }
}
</code></pre>

</div>
<h2 id="customheaders">Custom headers</h2>
<p>Express <code>Response</code> allows you to modify the response headers based on your needs. This is possible for all three options described above. Very important to note here is to configure the response <code>@Res({ passthrough: true })</code> when using <code>StreamableFile</code>, otherwise the response won't end.</p>
<p>Here are some examples how to customize the response headers for your endpoints or use <code>response.setHeaders(...)</code> for complete custom headers like caching.</p>
<h3 id="changethecontenttype">Change the content type</h3>
<p>By default <code>application/octet-stream</code> is set as the <code>Content-Type</code>. If you know you are returning an image or a document from your endpoint change the content type.</p>
<div shortcode="code" tabs="download.controller.ts">
<pre><code class="ts language-ts">@Get('buffer')
buffer(@Res() response: Response) {
  const file = this.downloadService.imageBuffer();
  response.contentType('png');
  // response.contentType('image/png');
  // response.contentType('image/*');
  // response.contentType('application/pdf');
  response.send(file);
}
</code></pre>

</div>
<h3 id="previewordownloadfile">Preview or download file</h3>
<p>Use the header <code>Content-Disposition</code> to inform if the file should be displayed <strong>inline</strong>, the default, or downloaded as an <strong>attachment</strong>. Use <code>response.attachment()</code> to indicate the file as download and optionally pass a <code>filename</code>.</p>
<div shortcode="code" tabs="download.controller.ts">
<pre><code class="ts language-ts">@Get('buffer')
buffer(@Res() response: Response) {
  const file = this.downloadService.imageBuffer();
  response.contentType('image/png');
  response.attachment();
  // provide a filename
  // response.attachment('notiz.png');
  response.send(file);
}
</code></pre>

</div>
<h2 id="swaggertypes">Swagger Types</h2>
<p>Until now, you covered the response part of the Rest API. How about Swagger? Does Swagger already know that the endpoint response is a file? Let's check it out at <code>http://localhost:3000/api</code>.</p>
<div shortcode="figure" caption="Download file without Swagger types">

![Download file without Swagger types](assets/img/blog/type-safe-file-downloads/optimized/download-file-without-swagger-types.png)

</div>
<p>Swagger is not aware about the file response and not even your custom content type. There is a way of telling Swagger about it. Can you spot the two <a href="https://docs.nestjs.com/openapi/decorators">decorators</a> for this job? üßê </p>
<p>The decorators for the job are <code>@ApiResponse</code> and <code>@ApiProduces</code>. ü§ù </p>
<p><code>@ApiResponse</code> is responsible for changing the response schema to a <code>binary</code> format. Similar to what you had to do for the <a href="https://notiz.dev/blog/type-safe-file-uploads#file-upload-decorators">type-safe file upload</a>.</p>
<div shortcode="code" tabs="download.controller.ts">
<pre><code class="ts language-ts">import { ApiResponse } from '@nestjs/swagger';

@ApiResponse({
  schema: {
    type: 'string',
    format: 'binary',
  },
  status: HttpStatus.OK,
})
@Get('buffer')
buffer(@Res() response: Response) {
  const file = this.downloadService.imageBuffer();
  response.contentType('image/png');
  response.send(file);
}
</code></pre>

</div>
<p>You can easily replace the decorator <code>@ApiResponse</code> with predefined status codes like <code>@ApiOkResponse</code>, <code>@ApiCreatedResponse</code> and skip the <code>status</code> code option.</p>
<p>Next, use <code>@ApiProduces</code> to inform Swagger about the response content type. It supports multiple content types and also wildcards (these things <code>*/*</code>, <code>image/*</code>).</p>
<div shortcode="code" tabs="download.controller.ts">
<pre><code class="ts language-ts">import { ApiOkResponse, ApiProduces } from '@nestjs/swagger';

@ApiOkResponse({
  schema: {
    type: 'string',
    format: 'binary',
  },
})
@ApiProduces('image/png')
@Get('buffer')
buffer(@Res() response: Response) {
  const file = this.downloadService.imageBuffer();
  response.contentType('image/png');
  response.send(file);
}
</code></pre>

</div>
<p>Your Swagger types should look as awesome as this. üëá</p>
<div shortcode="figure" caption="Download file with Swagger types">

![Download file with Swagger types](assets/img/blog/type-safe-file-downloads/optimized/download-file-with-swagger-types.png)

</div>
<p>Great, are you done yet? You are good to go, but there is one optimization you can do for simplifying the applied decorators. Why not create a custom <code>@ApiFileResponse</code> decorator to finish it up.</p>
<h2 id="fileresponsedecorator">File response decorator</h2>
<p>Add a new file <code>api-file-response.decorator.ts</code> and export a function called <code>ApiFileResponse</code> like the decorator. You'll create a <a href="https://docs.nestjs.com/custom-decorators#decorator-composition">composition</a> of <code>@ApiOkResponse</code> and <code>@ApiProduces</code>.</p>
<div shortcode="code" tabs="api-file-response.decorator.ts">
<pre><code class="ts language-ts">import { applyDecorators } from '@nestjs/common';
import { ApiOkResponse, ApiProduces } from '@nestjs/swagger';

export function ApiFileResponse(...mimeTypes: string[]) {
  return applyDecorators(
    ApiOkResponse({
      schema: {
        type: 'string',
        format: 'binary',
      },
    }),
    ApiProduces(...mimeTypes),
  );
}
</code></pre>

</div>
<p>That's looking good and you can still pass any content type (<code>mimeTypes</code>) as you wish. And it is as simple as that. ü§©</p>
<p><div shortcode="code" tabs="download.controller.ts"></p>
<pre><code class="ts language-ts">// before
import { ApiOkResponse, ApiProduces } from '@nestjs/swagger';

@ApiOkResponse({
  schema: {
    type: 'string',
    format: 'binary',
  },
})
@ApiProduces('image/png')
@Get('buffer')
buffer(@Res() response: Response) {
  const file = this.downloadService.imageBuffer();
  response.contentType('image/png');
  response.send(file);
}

// after
import { ApiFileResponse } from './api-file-response.decorator';

@ApiFileResponse('image/png')
@Get('buffer')
buffer(@Res() response: Response) {
  const file = this.downloadService.imageBuffer();
  response.contentType('image/png');
  response.send(file);
}
</code></pre>
<p>&lt;/div</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Maizzle: Craft beautiful HTML emails with Tailwind CSS]]></title>
        <id>/blog/send-beautiful-emails-crafted-with-maizzle</id>
        <link href="https://notiz.dev/blog/send-beautiful-emails-crafted-with-maizzle"/>
        <updated>2022-07-08T10:00:00.000Z</updated>
        <summary type="html"><![CDATA[Send beautiful HTML emails via NestJS crafted with Maizzle and Tailwind CSS]]></summary>
        <content type="html"><![CDATA[<p>Building beautiful HTML emails with CSS can be quite cumbersome üôÅ, right?!</p>
<p>Get ready to build beautiful email templates üñºÔ∏è crafted with <a href="https://maizzle.com">Maizzle</a> using <a href="https://tailwindcss.com">Tailwind CSS</a> and send them with your NestJS application.</p>
<p>Start with the previous post on how to create <a href="https://notiz.dev/blog/send-emails-with-nestjs">email templates and sending them from NestJS</a> with <a href="https://handlebarsjs.com">Handlebars</a>.</p>
<div shortcode="article" routes="/blog/send-emails-with-nestjs"></div>
<h2 id="maizzleproject">Maizzle project</h2>
<p><a href="https://maizzle.com/docs/installation#create-a-project">Add</a> a new Maizzle project to your NestJS repository.</p>
<div shortcode="note">

@maizzle/framework v4.x requires Node v14 or higher

</div>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npx degit maizzle/maizzle project-name

# for example
npx degit maizzle/maizzle mail-templates
</code></pre>

</div>
<p>Open the new project in your terminal and install the dependencies:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">cd mail-templates

npm install
</code></pre>

</div>
<p>Start the development server with <code>npm run dev</code> and go to <a href="http://localhost:3000">localhost:3000</a> in your browser to see your email templates. This is useful for local development.</p>
<p>When your templates are ready you want to build your email templates for production: </p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run build
</code></pre>

</div>
<p>You'll get to this in a bit. Next you'll customize the email confirmation template (<code>src/templates/transactional.html</code>) to include <a href="https://handlebarsjs.com/guide/#simple-expressions">Handlebar expressions</a>. </p>
<p>Open the <a href="http://localhost:3000/transactional.html">transaction template</a> in your browser and watch for the changes you'll make.</p>
<h2 id="handlebarexpressions">Handlebar expressions</h2>
<p>Ideally, when sending an email you want to customize the email content based on the requesting user. This includes greeting the user üëã (with name or email), links for interactions (confirming email, requesting new password) or personal links for managing mail preferences.</p>
<p>Open <code>src/templates/transactional.html</code> and add custom content through Handlebars expressions for <code>name</code> and <code>url</code> to the template.</p>
<div shortcode="code" tabs="transactional.html">
<pre><code class="html language-html">&lt;!-- ... --&gt;
&lt;p&gt;Hello {{name}},&lt;/p&gt; 
&lt;p class="m-0 ... sm:leading-8"&gt;
  Is it you we're looking for?
&lt;/p&gt;
&lt;p class="m-0 mb-6"&gt;
  Please confirm your email address by clicking the button below:
&lt;/p&gt;
&lt;div class="leading-full"&gt;
  &lt;a
    href="{{url}}"
    class="inline-block ... hover:bg-indigo-500"
  &gt;
    &lt;!-- ... --&gt;
    &lt;span class="mso-text-raise-4"&gt;Confirm email address &amp;rarr;&lt;/span&gt;
    &lt;!-- ... --&gt;
  &lt;/a&gt;
&lt;/div&gt;
&lt;!-- ... --&gt;
</code></pre>

</div>
<p>You'll notice that <code>{{name}}</code> is not displayed at all, instead you see <code>undefined</code> üò§.</p>
<div shortcode="figure" caption="Handlebars expressions are missing in email template">

![Handlebars expressions are missing in email template](assets/img/blog/send-beautiful-emails-crafted-with-maizzle/optimized/missing-handlebar-expressions.png)

</div>
<p>Thats because Maizzle itself relies on <a href="https://maizzle.com/docs/templates#expressions">curly brace expressions</a> to access variables or template front matter. </p>
<p>Luckily, Maizzle provides two options to <a href="https://maizzle.com/docs/templates#ignoring-expressions">prevent expression compilation</a> üòé. Use <code>@{{&amp;nbsp;}}</code> for single expression and <code>&lt;raw&gt; ... &lt;/raw&gt;</code> tag for blocks with multiple expressions.</p>
<p>Add the <code>@</code> prefix to the <code>name</code> and <code>url</code> expression and you should see <code>Hello {{name}},</code> in your compiled template.</p>
<div shortcode="code" tabs="transactional.html">
<pre><code class="html language-html">&lt;!-- ... --&gt;
&lt;p&gt;Hello @{{name}},&lt;/p&gt; 
&lt;p class="m-0 ... sm:leading-8"&gt;
  Is it you we're looking for?
&lt;/p&gt;
&lt;p class="m-0 mb-6"&gt;
  Please confirm your email address by clicking the button below:
&lt;/p&gt;
&lt;div class="leading-full"&gt;
  &lt;a
    href="@{{url}}"
    class="inline-block ... hover:bg-indigo-500"
  &gt;
    &lt;!-- ... --&gt;
    &lt;span class="mso-text-raise-4"&gt;Confirm email address &amp;rarr;&lt;/span&gt;
    &lt;!-- ... --&gt;
  &lt;/a&gt;
&lt;/div&gt;
&lt;!-- ... --&gt;
</code></pre>

</div>
<div shortcode="figure" caption="Handlebars expressions are ignored from compilation">

![Handlebars expressions are ignored from compilation](assets/img/blog/send-beautiful-emails-crafted-with-maizzle/optimized/ignored-handlebar-expressions.png)

</div>
<p>Your email template is looking great. Let's build the template for production and for NestJS to be used for sending emails.</p>
<h2 id="buildproductionemail">Build production email</h2>
<p>Maizzle provides a build command for production to inline CSS and many more optimizations.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run build
</code></pre>

</div>
<p>This compiles your emails by default to <code>mail-templates/build_production</code>. Let's change the <a href="https://maizzle.com/docs/configuration/templates#destination">destination</a> path to be located inside your NestJS - <code>src/mail/templates</code>.</p>
<p><code>config.production.js</code> contains settings used for the production build. Open it and change the destination path and change the extension to <code>hbs</code>.</p>
<pre><code class="js language-js">module.exports = {
  build: {
    templates: {
      destination: {
        path: '../src/mail/templates',
        extension: 'hbs'
      },
    },
  },
  inlineCSS: true,
  removeUnusedCSS: true,
}
</code></pre>
<p>Now when you run <code>npm run build</code> your templates will be compiled to <code>src/mail/templates/*.hbs</code>. </p>
<p>Cool üí™ your templates are ready and compiled for production. Use them in your NestJS application with <code>@nestjs-modules/mailer</code>.</p>
<h2 id="sendingmailtemplate">Sending mail template</h2>
<p>In the previous post you created the <code>MailService</code>.</p>
<div shortcode="code" tabs="mail.service.ts">
<pre><code class="ts language-ts">import { MailerService } from '@nestjs-modules/mailer';
import { Injectable } from '@nestjs/common';
import { User } from './../user/user.entity';

@Injectable()
export class MailService {
  constructor(private mailerService: MailerService) {}

  async sendUserConfirmation(user: User, token: string) {
    const url = `example.com/auth/confirm?token=${token}`;

    await this.mailerService.sendMail({
      to: user.email,
      subject: 'Welcome to Nice App! Confirm your Email',
      template: './confirmation', // üëà either change to ./transactional or rename transactional.html to confirmation.html
      context: { // ‚úèÔ∏è filling curly brackets with content
        name: user.name,
        url,
      },
    });
  }
}
</code></pre>

</div>
<p>Here you used <code>confirmation</code> as the template name. Either rename <code>transactional.html</code> to <code>confirmation.html</code> in <code>mail-templates/src/templates</code>, don't forget to compile again, or use <code>transactional</code> as the template name when using <code>this.mailerService.sendMail({...});</code>.</p>
<p>Awesome ü§© you are all set to build your own beautiful email templates. Comment below which templates you most often use in your applications. Checkout these <a href="https://github.com/mailpace/templates">transactional templates</a> build with Maizzle (v3.7.2) for some inspiration.</p>
<p>Do want to dig through the source code? Checkout the repository for this post.</p>
<p><div shortcode="repo" repo="notiz-dev/nestjs-mailer">&lt;/div</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prisma Migrate: Deploy Migration with Docker]]></title>
        <id>/blog/prisma-migrate-deploy-with-docker</id>
        <link href="https://notiz.dev/blog/prisma-migrate-deploy-with-docker"/>
        <updated>2021-11-22T09:40:00.000Z</updated>
        <summary type="html"><![CDATA[Perform database migration with Prisma Migrate using Docker]]></summary>
        <content type="html"><![CDATA[<p>One question about the guide <a href="/blog/dockerizing-nestjs-with-prisma-and-postgresql">Dockerizing a NestJS app with Prisma and PostgreSQL</a> was asked frequently: "How to run database migrations in production?"</p>
<p>Let's dive into this topic and find out how to use <code>prisma migrate deploy</code> with Docker for your production database.</p>
<p>Prisma recommends to perform migrations for production database in an <a href="https://www.prisma.io/docs/concepts/components/prisma-migrate#production-and-testing-environments">automated step</a> and advises against performing it locally üôÖ‚Äç‚ôÇÔ∏è</p>
<h2 id="prismamigratewithdocker">Prisma Migrate with Docker</h2>
<p>Let's take a look at how to integrate the command <code>prisma migrate deploy</code> into the following <code>Dockerfile</code>.</p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker">FROM node:14 AS builder

# Create app directory
WORKDIR /app

# A wildcard is used to ensure both package.json AND package-lock.json are copied
COPY package*.json ./
COPY prisma ./prisma/

# Install app dependencies
RUN npm install

COPY . .

RUN npm run build

# as build step‚ùì

FROM node:14

COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/dist ./dist

EXPOSE 3000
# or during execution ‚ùì
CMD [ "npm", "run", "start:prod" ]
</code></pre>

</div>
<p>First of all, one command is very important: <code>COPY prisma ./prisma/</code>. This makes sure to <strong>not</strong> only copy the <code>schema.prisma</code> into the Docker image, but also includes the <code>migrations</code> directory. This is necessary as <code>prisma migrate deploy</code> only executes the <a href="https://www.prisma.io/docs/concepts/components/prisma-migrate#source-controlling-the-migration-history">migration history files</a>.</p>
<h3 id="addaruncommand">Add a RUN command ‚ùå</h3>
<p>What about adding <code>RUN npx prisma migrate deploy</code> to the <code>Dockerfile</code>?<br />
Two issues that come to mind are making it not a good solution.</p>
<ol>
<li>Performs migration during build step, not before Docker container is started</li>
<li>CI/CD needs access to your production database, requires <code>DATABASE_URL</code> environment</li>
</ol>
<p><code>RUN</code> commands are executed during the build steps of your the Docker image. Time may pass between the database migration and restarting the Docker container (Nest app), leaving your database and Nest app in <strong>different</strong> states. Additionally, when you create your Docker image in a CI/CD pipeline, the server needs access to the production database to perform the migration.</p>
<h3 id="addtocmd">Add to CMD ‚úÖ</h3>
<p>A better approach is to perform the migration just before starting your Nest app.</p>
<p>Nest app is started with the last command <code>CMD [ "npm", "run", "start:prod" ]</code>. <a href="https://docs.docker.com/engine/reference/builder/#cmd">CMD</a> is not executed during the build steps of your Docker image, rather than during executing the Docker container (<code>docker run ...</code> or <code>docker-compose up</code>).</p>
<p>This is a multi-stage build <code>Dockerfile</code>, you need to copy the <code>prisma</code> directory including the <strong>migration history</strong> into the second stage.</p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker">FROM node:14 AS builder

# build steps
...

RUN npm run build

FROM node:14

COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/dist ./dist
# üëá copy prisma directory
COPY --from=builder /app/prisma ./prisma

EXPOSE 3000
CMD [  "npm", "run", "start:prod" ]
</code></pre>

</div>
<p>Add a new script to your <code>package.json</code> to execute <code>prisma migrate deploy &amp;&amp; npm run start:prod</code>.</p>
<div shortcode="code" tabs="package.json">
<pre><code class="json language-json">{
  ...
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "start:migrate:prod": "prisma migrate deploy &amp;&amp; npm run start:prod", // new script üëà
  },
  ...
}
</code></pre>

</div>
<p>Use the new script as <code>CMD</code> command</p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker">FROM node:14 AS builder

# Create app directory
WORKDIR /app

# A wildcard is used to ensure both package.json AND package-lock.json are copied
COPY package*.json ./
COPY prisma ./prisma/

# Install app dependencies
RUN npm install

COPY . .

RUN npm run build

FROM node:14

COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/prisma ./prisma

EXPOSE 3000
# üëá new migrate and start app script
CMD [  "npm", "run", "start:migrate:prod" ]
</code></pre>

</div>
<div shortcode="note" type="warn">
When testing locally make sure that your `DATABASE_URL` in your `.env` file is **not** using `localhost` as the host üôÖ‚Äç‚ôÇÔ∏è. Replace `localhost` with the database container name.
</div>
<p>Now start your Docker containers with <code>docker-compose up</code> to see the logs and verify that your migrations are performed. In case all migrations have already been applied to your database, Prisma Migrate will complete with "No pending migrations to apply.".</p>
<div shortcode="code" tabs="Migrations performed,No pending migrations">
<pre><code class="bash language-bash">postgresprisma | 2021-11-09 15:24:30.189 UTC [1] LOG:  database system is ready to accept connections
nest-api    | 
nest-api    | &gt; nestjs-prisma-docker@0.0.1 start:prod:docker /
nest-api    | &gt; npm run migrate:deploy &amp;&amp; npm run start:prod
nest-api    | 
nest-api    | 
nest-api    | &gt; nestjs-prisma-docker@0.0.1 migrate:deploy /
nest-api    | &gt; prisma migrate deploy
nest-api    | 
nest-api    | Prisma schema loaded from prisma/schema.prisma
nest-api    | Datasource "db": PostgreSQL database "food", schema "public" at "postgresprisma:5432"
postgresprisma | 2021-11-09 15:24:38.959 UTC [34] ERROR:  relation "_prisma_migrations" does not exist at character 126
postgresprisma | 2021-11-09 15:24:38.959 UTC [34] STATEMENT:  SELECT "id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count" FROM "_prisma_migrations" ORDER BY "started_at" ASC
nest-api    | 
nest-api    | 1 migration found in prisma/migrations
nest-api    | 
nest-api    | Applying migration `20210603130425_init`
nest-api    | 
nest-api    | The following migration have been applied:
nest-api    | 
nest-api    | migrations/
nest-api    |   ‚îî‚îÄ 20210603130425_init/
nest-api    |     ‚îî‚îÄ migration.sql
nest-api    |       
nest-api    | All migrations have been successfully applied.
nest-api    | 
nest-api    | &gt; nestjs-prisma-docker@0.0.1 start:prod /
nest-api    | &gt; node dist/main
nest-api    | 
nest-api    | [Nest] 174  - 11/09/2021, 3:24:40 PM     LOG [NestFactory] Starting Nest application...
nest-api    | [Nest] 174  - 11/09/2021, 3:24:40 PM     LOG [InstanceLoader] PrismaModule dependencies initialized +73ms
nest-api    | [Nest] 174  - 11/09/2021, 3:24:40 PM     LOG [InstanceLoader] AppModule dependencies initialized +0ms
nest-api    | [Nest] 174  - 11/09/2021, 3:24:40 PM     LOG [RoutesResolver] AppController {/}: +14ms
nest-api    | [Nest] 174  - 11/09/2021, 3:24:40 PM     LOG [RouterExplorer] Mapped {/, GET} route +7ms
nest-api    | [Nest] 174  - 11/09/2021, 3:24:40 PM     LOG [RouterExplorer] Mapped {/foods, GET} route +1ms
nest-api    | [Nest] 174  - 11/09/2021, 3:24:40 PM     LOG [NestApplication] Nest application successfully started +65ms
</code></pre><pre><code class="bash language-bash">postgresprisma | 2021-11-09 16:20:52.899 UTC [1] LOG:  database system is ready to accept connections
nest-api    | 
nest-api    | &gt; nestjs-prisma-docker@0.0.1 start:prod:docker /
nest-api    | &gt; npm run migrate:deploy &amp;&amp; npm run start:prod
nest-api    | 
nest-api    | 
nest-api    | &gt; nestjs-prisma-docker@0.0.1 migrate:deploy /
nest-api    | &gt; prisma migrate deploy
nest-api    | 
nest-api    | Prisma schema loaded from prisma/schema.prisma
nest-api    | Datasource "db": PostgreSQL database "food", schema "public" at "postgresprisma:5432"
nest-api    | 
nest-api    | 1 migration found in prisma/migrations
nest-api    | 
nest-api    | 
nest-api    | No pending migrations to apply.
nest-api    | 
nest-api    | &gt; nestjs-prisma-docker@0.0.1 start:prod /
nest-api    | &gt; node dist/main
nest-api    | 
nest-api    | [Nest] 174  - 11/09/2021, 4:20:55 PM     LOG [NestFactory] Starting Nest application...
nest-api    | [Nest] 174  - 11/09/2021, 4:20:56 PM     LOG [InstanceLoader] PrismaModule dependencies initialized +69ms
nest-api    | [Nest] 174  - 11/09/2021, 4:20:56 PM     LOG [InstanceLoader] AppModule dependencies initialized +1ms
nest-api    | [Nest] 174  - 11/09/2021, 4:20:56 PM     LOG [RoutesResolver] AppController {/}: +12ms
nest-api    | [Nest] 174  - 11/09/2021, 4:20:56 PM     LOG [RouterExplorer] Mapped {/, GET} route +8ms
nest-api    | [Nest] 174  - 11/09/2021, 4:20:56 PM     LOG [RouterExplorer] Mapped {/foods, GET} route +1ms
nest-api    | [Nest] 174  - 11/09/2021, 4:20:56 PM     LOG [NestApplication] Nest application successfully started +62ms
</code></pre>

</div>
<p>Hurray üéâ the database migrations are executing successfully with Docker! Test it out on your test, staging and then production environment.</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Media Queries with RxJS]]></title>
        <id>/blog/media-observable</id>
        <link href="https://notiz.dev/blog/media-observable"/>
        <updated>2021-09-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Media Queries | Practical examples with RxJS]]></summary>
        <content type="html"><![CDATA[<h2 id="tldr">tl;dr</h2>
<p>It's super easy to handle Media Queries</span> programmatically with <span type="underline" delay="1200" shortcode="annotate">RxJS</span>! ü§ó</p>
<div shortcode="scroll-to" fragment="media-queries-with-rxjs">
<a>Take me to the code!</a>
</div>
<div shortcode="repo" repo="garygrossgarten/media-query"></div>
<div shortcode="demos/breakpoints"></div>
<h2 id="introduction">Introduction</h2>
<h3 id="mediaqueriesincss">Media Queries in CSS</h3>
<p><a href="https://www.w3schools.com/css/css_rwd_mediaqueries.asp">Media Queries</a> are essential tools when building responsive layouts on the web. They are commonly used to hide / show / alter parts of the UI depending on the viewport dimensions or to switch between themes based on user preferences (e.g. Darkmode üåô).</p>
<p>In CSS Media Queries are used like so.</p>
<div shortcode="code" tabs="styles.css">
<pre><code class="css language-css">@media (max-width: 767px) {
  /* apply styles */
}
</code></pre>

</div>
<p>Although this is already pretty great, we sometimes want to <strong>handle the state of a media query programmatically</strong>. For example, preventing the render of some components or dom elements on certain viewport sizes instead of just hiding things with <code>display: none</code> could lead to a better performance and less network requests to your server.</p>
<h3 id="mediaqueriesinjavascript">Media Queries in JavaScript</h3>
<p>The vanilla javascript way of implementing such a functionality would be to use the window's <code>matchMedia</code> function. The function takes a string query and returns a <code>MediaQueryList</code> that can be used to get the current result of the query and listen to changes of the media query.</p>
<div shortcode="code" tabs="JS">
<pre><code class="js language-js">const mediaQueryList = window.matchMedia(`(min-width: 767px)`);

console.log(mediaQueryList.matches); // true or false

mediaQueryList.addEventListener('change', (event) =&gt;
  console.log(event.matches) // true or false
);

// don't forget to remove the event listener ;)
</code></pre>

</div>
<h2 id="mediaquerieswithrxjs">Media Queries with RxJS</h2>
<p>As an Angular developer, I make heavy use of <a href="https://rxjs.dev/">RxJS</a> in my applications. To neatly integrate Media Queries in my workflow I came up with the media Observable. </p>
<div shortcode="code" tabs="media.ts">
<pre><code class="ts language-ts">import { fromEvent, Observable } from 'rxjs';
import { startWith, map } from 'rxjs/operators';

export function media(query: string): Observable&lt;boolean&gt; {
  const mediaQuery = window.matchMedia(query);
  return fromEvent&lt;MediaQueryList&gt;(mediaQuery, 'change').pipe(
    startWith(mediaQuery),
    map((list: MediaQueryList) =&gt; list.matches)
  );
}

// Usage
media('(max-width: 767px)').subscribe((matches) =&gt;
  console.log(matches) // true or false
);
</code></pre>

</div>
<p>We use RxJS <code>fromEvent</code> Observable creation function to listen for all changes to the <code>MediaQueryList</code>. To get the inital <code>MediaQueryList</code>, we use the <code>startWith</code> operator. The <code>MediaQueryList</code> is then mapped to the actual result of the query by using the <code>matches</code> function.</p>
<div shortcode="note">

The `media` function returns a `Observable<boolean>` stream which can be used to subscribe to the current state and 
future changes of the media query.

</div>
<h2 id="demos">Demos</h2>
<p>The demos were built in an Angular workspace. As you can see, I make use of Angular's <code>async</code> pipe to subscribe to the media Observables.</p>
<h3 id="breakpointsdemo">Breakpoints demo</h3>
<p>In this demo we use the media Observable to track the default Tailwind CSS screen breakpoints. Depending on the viewport dimensions certain elements are hidden using <code>*ngIf</code>. Resize your browser window to see the breakpoints change.</p>
<div shortcode="demos/responsive"></div>
<div shortcode="code" tabs="TS,HTML">
<pre><code class="ts language-ts">import { Component, HostBinding } from '@angular/core';
import { media } from './media';

@Component({
  selector: 'demo-breakpoints',
  templateUrl: 'breakpoints.component.ts',
})
export class BreakPointsComponent {

  sm$ = media(`(max-width: 767px)`);
  md$ = media(`(min-width: 768px) and (max-width: 1023px)`);
  lg$ = media(`(min-width: 1024px) and (max-width: 1279px)`);
  xl$ = media(`(min-width: 1280px) and (max-width: 1535px)`);
  xl2$ = media(`(min-width: 1536px)`);

}
</code></pre><pre><code class="html language-html">&lt;div *ngIf="sm$ | async"&gt;sm&lt;/div&gt;
&lt;div *ngIf="md$ | async"&gt;md&lt;/div&gt;
&lt;div *ngIf="lg$ | async"&gt;lg&lt;/div&gt;
&lt;div *ngIf="xl$ | async"&gt;xl&lt;/div&gt;
&lt;div *ngIf="xl2$ | async"&gt;2xl&lt;/div&gt;
</code></pre>

</div>
<h3 id="devicebrowserpreferencesdemo">Device / Browser preferences demo</h3>
<p>This demo watches device / browser preferences and the viewport orientation.</p>
<div shortcode="demos/preferences"></div>
<div shortcode="code" tabs="TS,HTML">
<pre><code class="ts language-ts">import { Component, HostBinding } from '@angular/core';
import { media } from './media';

@Component({
  selector: 'demo-preferences',
  templateUrl:'preferences.component.html',
})
export class PreferencesComponent {
  @HostBinding('class') class = 'block relative space-y-4';

  prefersLight$ = media('(prefers-color-scheme: light)');
  prefersDark$ = media('(prefers-color-scheme: dark)');
  prefersReducedMotion$ = media('(prefers-reduced-motion:reduce)');
  prefersReducedTransparency$ = media('(prefers-reduced-transparency:reduce)');
  prefersReducedData$ = media('(prefers-reduced-data: reduce)');
  prefersContrast$ = media('(prefers-contrast:high)');
  portrait$ = media('(orientation: portrait)');
  landscape$ = media('(orientation: landscape)');
}
</code></pre><pre><code class="html language-html">&lt;div class="p-4 rounded-xl bg-canvas-shade grid md:grid-cols-2 gap-4"&gt;
  &lt;div [ngClass]="{ 'opacity-30': !(prefersDark$ | async) }"&gt;
    prefers-color-scheme: dark
  &lt;/div&gt;
  &lt;div [ngClass]="{ 'opacity-30': !(prefersLight$ | async) }"&gt;
    prefers-color-scheme: light
  &lt;/div&gt;
  &lt;div [ngClass]="{ 'opacity-30': !(prefersReducedMotion$ | async) }"&gt;
    prefers-reduced-motion: reduce
  &lt;/div&gt;
  &lt;div [ngClass]="{ 'opacity-30': !(prefersReducedTransparency$ | async) }"&gt;
    prefers-reduced-transparency: reduce
  &lt;/div&gt;
  &lt;div [ngClass]="{ 'opacity-30': !(prefersReducedData$ | async) }"&gt;
    prefers-reduced-data: reduce
  &lt;/div&gt;
  &lt;div [ngClass]="{ 'opacity-30': !(prefersContrast$ | async) }"&gt;
    prefers-contract: high
  &lt;/div&gt;
  &lt;div [ngClass]="{ 'opacity-30': !(portrait$ | async) }"&gt;
    orientation: portrait
  &lt;/div&gt;
  &lt;div [ngClass]="{ 'opacity-30': !(landscape$ | async) }"&gt;
    orientation: landscape
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

</div>
<p>If you have further questions, feel free to contact me! </p>
<p><div shortcode="author" name="Gary Gro√ügarten">&lt;/div</p>]]></content>
        <author>
            <name>Gary Gro√ügarten</name>
        </author>
        <contributor>
            <name>gary-gro√ügarten</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[NestJS: Type-safe File Uploads]]></title>
        <id>/blog/type-safe-file-uploads</id>
        <link href="https://notiz.dev/blog/type-safe-file-uploads"/>
        <updated>2021-08-26T09:55:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to apply Swagger decorators for type-safe file upload endpoints.]]></summary>
        <content type="html"><![CDATA[<p>You will setup REST endpoints for <a href="https://docs.nestjs.com/techniques/file-upload">uploading files</a>, add Swagger decorators for type-safety and learn about <a href="https://docs.nestjs.com/custom-decorators#decorator-composition">Decorator composition</a> to simplify Swagger decorators.</p>
<p>Before you start follow the setup for Swagger in your NestJS application.</p>
<div shortcode="article" routes="/blog/openapi-in-nestjs"></div>
<p>The source code for this post is available in this repo on GitHub.</p>
<div shortcode="repo" repo="notiz-dev/nestjs-swagger"></div>
<h2 id="getstarted">Get Started</h2>
<p>Nest uses <a href="https://github.com/expressjs/multer">multer</a> for handling file uploads using the <code>multipart/form-data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST">format</a>.</p>
<p>Add the multer typings to improve type-safety.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm i -D @types/multer
</code></pre>

</div>
<h2 id="uploadfiles">Upload File(s)</h2>
<p>Start with uploading a single file. Add a new <code>Post</code> endpoint to your controller and add the <code>FileInterceptor()</code> to extract the file from the request. Gain access to the file payload via the <code>@UploadedFile()</code> decorator.</p>
<div shortcode="code" tabs="files.controller.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Post,
  UploadedFile,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { ApiTags } from '@nestjs/swagger';
import { FilesService } from './files.service';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @UseInterceptors(FileInterceptor('file'))
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }
}
</code></pre>

</div>
<p>Start the Nest application <code>npm run start:dev</code> and checkout the new endpoint in your Swagger API <a href="http://localhost:3000/api">localhost:3000/api</a>.</p>
<div shortcode="figure" caption="Upload file without Swagger types">

![Upload file without Swagger types](assets/img/blog/type-safe-file-uploads/optimized/upload-file-without-swagger-types.png)

</div>
<p>The endpoint is available but Swagger doesn't now anything about the file upload. Let's add the Swagger type definitions for uploading a file.</p>
<p>First, you add <a href="https://docs.nestjs.com/openapi/operations#file-upload">@ApiConsumes()</a> to let Swagger now that this endpoint is consuming <code>multipart/form-data</code>. Now use <code>@ApiBody()</code> to enable file upload in the Swagger API.</p>
<div shortcode="code" tabs="files.controller.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Post,
  UploadedFile,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { ApiBody, ApiConsumes, ApiTags } from '@nestjs/swagger';
import { FilesService } from './files.service';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @UseInterceptors(FileInterceptor('file')) // üëà field name must match
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: { // üëà this property
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }
}
</code></pre>

</div>
<div shortcode="note">
The parameter for `@FileInterceptor()` must match the name of the properties field in the `@ApiBody()`. Otherwise Nest returns `400 Unexpected field`.
</div>
<p>Swagger provides you now with a file selection üéâ.</p>
<div shortcode="figure" caption="Upload file with Swagger types">

![Upload file without Swagger types](assets/img/blog/type-safe-file-uploads/optimized/upload-file-with-swagger-types.png)

</div>
<p>Now create endpoints for uploading <a href="https://docs.nestjs.com/techniques/file-upload#array-of-files">array of files</a> - <code>@FilesInterceptor()</code> and <code>@UploadedFiles()</code> - and <a href="https://docs.nestjs.com/techniques/file-upload#multiple-files">multiple files</a> - <code>@FileFieldsInterceptor()</code> and <code>@UploadedFiles()</code>.</p>
<div shortcode="code" tabs="files.controller.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Post,
  UploadedFile,
  UploadedFiles,
  UseInterceptors,
} from '@nestjs/common';
import {
  FileFieldsInterceptor,
  FileInterceptor,
  FilesInterceptor,
} from '@nestjs/platform-express';
import { ApiBody, ApiConsumes, ApiTags } from '@nestjs/swagger';
import { FilesService } from './files.service';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @UseInterceptors(FileInterceptor('file'))
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }

  @Post('uploads')
  @UseInterceptors(FilesInterceptor('files')) // üëà  using FilesInterceptor here
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        files: {
          type: 'array', // üëà  array of files
          items: {
            type: 'string',
            format: 'binary',
          },
        },
      },
    },
  })
  uploadFiles(@UploadedFiles() files: Array&lt;Express.Multer.File&gt;) {
    console.log(files);
  }

  @Post('uploadFields')
  @UseInterceptors(
    FileFieldsInterceptor([ // üëà  multiple files with different field names 
      { name: 'avatar', maxCount: 1 },
      { name: 'background', maxCount: 1 },
    ]),
  )
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: { 
        // üëà  field names need to be repeated for swagger
        avatar: {
          type: 'string',
          format: 'binary',
        },
        background: {
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  uploadMultipleFiles(@UploadedFiles() files: Express.Multer.File[]) {
    console.log(files);
  }
}
</code></pre>

</div>
<p>Checkout the new endpoints in your Swagger API.</p>
<div shortcode="figure" caption="Upload array of files with Swagger types">

![Upload array of files with Swagger types](assets/img/blog/type-safe-file-uploads/optimized/upload-files-with-swagger-types.png)

</div>
<div shortcode="figure" caption="Upload multiple files with different field names with Swagger types">

![Upload array of files with Swagger types](assets/img/blog/type-safe-file-uploads/optimized/upload-file-fields-with-swagger-types.png)

</div>
<p>As you noticed you need to add a <strong>few</strong> decorators to your endpoints and <strong>repeat</strong> the definition again for Swagger to pick up the correct file types. This is quite error prone as you might forget to add decorator or use the wrong file name property.</p>
<p>Let's improve it by creating custom decorators for file uploads and combining all required decorators together.</p>
<h2 id="fileuploaddecorators">File upload decorators</h2>
<p>Create a new file called <code>api-file.decorator.ts</code> and export a function called <code>ApiFile</code> which returns <code>applyDecorators()</code> provided by Nest. Copy all decorators required for handling file upload <code>FileInterceptor()</code>, <code>@ApiConsumes</code> and <code>ApiBody</code> into <code>applyDecorators()</code>.</p>
<div shortcode="code" tabs="api-file.decorator.ts">
<pre><code class="ts language-ts">import { applyDecorators, UseInterceptors } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { ApiBody, ApiConsumes } from '@nestjs/swagger';

export function ApiFile() {
  return applyDecorators(
    UseInterceptors(FileInterceptor('file')),
    ApiConsumes('multipart/form-data'),
    ApiBody({
      schema: {
        type: 'object',
        properties: {
          file: {
            type: 'string',
            format: 'binary',
          },
        },
      },
    }),
  );
}
</code></pre>

</div>
<p>Now you can replace those decorators and use <code>@ApiFile()</code> instead.</p>
<div shortcode="code" tabs="files.controller.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Post,
  UploadedFile,
} from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { ApiFile } from './api-file.decorator';
import { FilesService } from './files.service';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @ApiFile() // ü§ô cleaned up decorators
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }
</code></pre>

</div>
<p>What if you want to upload a file with a different field name than <code>file</code>? Add a <code>fieldName</code> parameter to <code>ApiFile</code> and set the default to <code>file</code>. Replace <code>file</code> with the new <code>fieldName</code> property. You can even go a step further and add <code>required</code> and <code>MulterOptions</code> as optional parameters.</p>
<div shortcode="code" tabs="api-file.decorator.ts">
<pre><code class="ts language-ts">import { applyDecorators, UseInterceptors } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { MulterOptions } from '@nestjs/platform-express/multer/interfaces/multer-options.interface';
import { ApiBody, ApiConsumes } from '@nestjs/swagger';

export function ApiFile(
  fieldName: string = 'file',
  required: boolean = false,
  localOptions?: MulterOptions,
) {
  return applyDecorators(
    UseInterceptors(FileInterceptor(fieldName, localOptions)),
    ApiConsumes('multipart/form-data'),
    ApiBody({
      schema: {
        type: 'object',
        required: required ? [fieldName] : [],
        properties: {
          [fieldName]: {
            type: 'string',
            format: 'binary',
          },
        },
      },
    }),
  );
}
</code></pre>

</div>
<p>This solves the problem that the <code>fieldName</code> for the <code>FileInterceptor</code> and the <code>ApiBody</code> are always the same and is convenient and easy to reuse.</p>
<div shortcode="code" tabs="files.controller.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Post,
  UploadedFile,
} from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { ApiFile } from './api-file.decorator';
import { FilesService } from './files.service';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @ApiFile('avatar', true) // ü§© changing field name and set file required
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }
}
</code></pre>

</div>
<p>Now create decorators for <code>@ApiFiles()</code> and <code>@ApiFileFields()</code>.</p>
<div shortcode="code" tabs="api-files.decorator.ts,api-file-fields.decorator.ts">
<pre><code class="ts language-ts">import { applyDecorators, UseInterceptors } from '@nestjs/common';
import { FilesInterceptor } from '@nestjs/platform-express';
import { MulterOptions } from '@nestjs/platform-express/multer/interfaces/multer-options.interface';
import { ApiBody, ApiConsumes } from '@nestjs/swagger';

export function ApiFiles(
  fieldName: string = 'files',
  required: boolean = false,
  maxCount: number = 10,
  localOptions?: MulterOptions,
) {
  return applyDecorators(
    UseInterceptors(FilesInterceptor(fieldName, maxCount, localOptions)),
    ApiConsumes('multipart/form-data'),
    ApiBody({
      schema: {
        type: 'object',
        required: required ? [fieldName] : [],
        properties: {
          [fieldName]: {
            type: 'array',
            items: {
              type: 'string',
              format: 'binary',
            },
          },
        },
      },
    }),
  );
}
</code></pre><pre><code class="ts language-ts">import { applyDecorators, UseInterceptors } from '@nestjs/common';
import { FileFieldsInterceptor } from '@nestjs/platform-express';
import {
  MulterField,
  MulterOptions,
} from '@nestjs/platform-express/multer/interfaces/multer-options.interface';
import { ApiBody, ApiConsumes } from '@nestjs/swagger';
import {
  ReferenceObject,
  SchemaObject,
} from '@nestjs/swagger/dist/interfaces/open-api-spec.interface';

export type UploadFields = MulterField &amp; { required?: boolean };

export function ApiFileFields(
  uploadFields: UploadFields[],
  localOptions?: MulterOptions,
) {
  const bodyProperties: Record&lt;string, SchemaObject | ReferenceObject&gt; =
    Object.assign(
      {},
      ...uploadFields.map((field) =&gt; {
        return { [field.name]: { type: 'string', format: 'binary' } };
      }),
    );
  const apiBody = ApiBody({
    schema: {
      type: 'object',
      properties: bodyProperties,
      required: uploadFields.filter((f) =&gt; f.required).map((f) =&gt; f.name),
    },
  });

  return applyDecorators(
    UseInterceptors(FileFieldsInterceptor(uploadFields, localOptions)),
    ApiConsumes('multipart/form-data'),
    apiBody,
  );
}
</code></pre>

</div>
<p>Now compare the endpoints without and with custom file upload decorators</p>
<div shortcode="code" tabs="Before,After">
<pre><code class="ts language-ts">import {
  Controller,
  Post,
  UploadedFile,
  UploadedFiles,
  UseInterceptors,
} from '@nestjs/common';
import {
  FileFieldsInterceptor,
  FileInterceptor,
  FilesInterceptor,
} from '@nestjs/platform-express';
import { ApiBody, ApiConsumes, ApiTags } from '@nestjs/swagger';
import { FilesService } from './files.service';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @UseInterceptors(FileInterceptor('file'))
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }

  @Post('uploads')
  @UseInterceptors(FilesInterceptor('files')) // üëà  using FilesInterceptor here
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        files: {
          type: 'array', // üëà  array of files
          items: {
            type: 'string',
            format: 'binary',
          },
        },
      },
    },
  })
  uploadFiles(@UploadedFiles() files: Array&lt;Express.Multer.File&gt;) {
    console.log(files);
  }

  @Post('uploadFields')
  @UseInterceptors(
    FileFieldsInterceptor([ // üëà  multiple files with different field names 
      { name: 'avatar', maxCount: 1 },
      { name: 'background', maxCount: 1 },
    ]),
  )
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: { 
        // üëà  field names need to be repeated for swagger
        avatar: {
          type: 'string',
          format: 'binary',
        },
        background: {
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  uploadMultipleFiles(@UploadedFiles() files: Express.Multer.File[]) {
    console.log(files);
  }
}
</code></pre><pre><code class="ts language-ts">import { Controller, Post, UploadedFile, UploadedFiles } from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { ApiFileFields } from './api-file-fields.decorator';
import { ApiFile } from './api-file.decorator';
import { ApiFiles } from './api-files.decorator';
import { FilesService } from './files.service';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @ApiFile('avatar', false)
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }

  @Post('uploads')
  @ApiFiles('files', true)
  uploadFiles(@UploadedFiles() files: Array&lt;Express.Multer.File&gt;) {
    console.log(files);
  }

  @Post('uploadFields')
  @ApiFileFields([
    { name: 'avatar', maxCount: 1, required: true },
    { name: 'background', maxCount: 1 },
  ])
  uploadMultipleFiles(@UploadedFiles() files: Express.Multer.File[]) {
    console.log(files);
  }
}
</code></pre>

</div>
<h2 id="customfilefilter">Custom file filter</h2>
<p>What if you like to allow only images or PDF's to upload? Thats where the <code>MulterOptions.fileFilter</code> come into action. You can filter based on the file properties such as <code>originalname</code>, <code>mimetype</code>, <code>size</code> and more. </p>
<p>Let's create a filter for mimetypes call the function <code>fileMimetypeFilter</code> which receives one or more mimetypes to match, use the spread operator for the parameter. The <code>fileMimetypeFilter</code> return and implements the multer filter signature.</p>
<div shortcode="code" tabs="file-mimetype-filter.ts">
<pre><code class="ts language-ts">import { UnsupportedMediaTypeException } from '@nestjs/common';

export function fileMimetypeFilter(...mimetypes: string[]) {
  return (
    req,
    file: Express.Multer.File,
    callback: (error: Error | null, acceptFile: boolean) =&gt; void,
  ) =&gt; {
    if (mimetypes.some((m) =&gt; file.mimetype.includes(m))) {
      callback(null, true);
    } else {
      callback(
        new UnsupportedMediaTypeException(
          `File type is not matching: ${mimetypes.join(', ')}`,
        ),
        false,
      );
    }
  };
}
</code></pre>

</div>
<p>Add the filter to the <code>@ApiFile()</code>, <code>@ApiFiles()</code> or <code>@ApiFileFields()</code> decorators <code>localOptions</code> object.</p>
<div shortcode="code" tabs="files.controller.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Post,
  UploadedFile,
} from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { ApiFile } from './api-file.decorator';
import { FilesService } from './files.service';
import { fileMimetypeFilter } from './file-mimetype-filter';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @ApiFile('avatar', true, { fileFilter: fileMimetypeFilter('image') }) 
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }
}
</code></pre>

</div>
<p>This endpoint only accepts files which include the mimetype <code>image</code> such as <code>image/jpeg</code> or <code>image/png</code>. This is already very quick and the <code>fileMimetypeFilter</code> can be reused. </p>
<p>But heck why not create custom decorators based on the supported mimetype. Let's create two example decorators: <code>ApiImageFile</code> and <code>ApiPdfFile</code>. They are simple functions returning the previous created <code>ApiFile</code> (or <code>ApiFiles</code>) decorator and specifying the <code>fileMimetypeFilter()</code>.</p>
<div shortcode="code" tabs="api-file.decorator.ts">
<pre><code class="ts language-ts">import { fileMimetypeFilter } from './file-mimetype-filter';

export function ApiImageFile(
  fileName: string = 'image',
  required: boolean = false,
) {
  return ApiFile(fileName, required, {
    fileFilter: fileMimetypeFilter('image'),
  });
}

export function ApiPdfFile(
  fileName: string = 'document',
  required: boolean = false,
) {
  return ApiFile(fileName, required, {
    fileFilter: fileMimetypeFilter('pdf'),
  });
}
</code></pre>

</div>
<p>Now simply use <code>@ApiImageFile</code> or <code>@ApiPdfFile</code> to handle file uploads.</p>
<div shortcode="code" tabs="files.controller.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Post,
  UploadedFile,
} from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { ApiImageFile, ApiPdfFile  } from './api-file.decorator';
import { FilesService } from './files.service';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('avatar')
  @ApiImageFile('avatar', true)
  uploadAvatar(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }

  @Post('document')
  @ApiPdfFile('document', true)
  uploadDocument(@UploadedFile() file: Express.Multer.File) {
    console.log(file);
  }
}
</code></pre>

</div>
<h2 id="filevalidation">File validation</h2>
<p>Until now, files are only set to required for the Swagger API. If you call the endpoint from a web framework or REST client like Insomnia you are receiving a <code>201</code> status and the received file is <code>undefined</code>. </p>
<p>To validate, a file is not <code>undefined</code> create a custom pipe, let's called it <code>ParseFile</code>. The pipe will check if the file is provided or not and throw a <code>400 Bad Request</code> exception. </p>
<div shortcode="code" tabs="parse-file.pipe.ts">
<pre><code class="ts language-ts">import {
  ArgumentMetadata,
  Injectable,
  PipeTransform,
  BadRequestException,
} from '@nestjs/common';

@Injectable()
export class ParseFile implements PipeTransform {
  transform(
    files: Express.Multer.File | Express.Multer.File[],
    metadata: ArgumentMetadata,
  ): Express.Multer.File | Express.Multer.File[] {
    if (files === undefined || files === null) {
      throw new BadRequestException('Validation failed (file expected)');
    }

    if (Array.isArray(files) &amp;&amp; files.length === 0) {
      throw new BadRequestException('Validation failed (files expected)');
    }

    return files;
  }
}
</code></pre>

</div>
<p>Pass the <code>ParseFile</code> to the <code>@UploadFile()</code> or <code>@UploadFiles()</code> decorator and you now receive a <code>400 Bad Request</code> if the file is not provided.</p>
<div shortcode="code" tabs="files.controller.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Post,
  UploadedFile,
} from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { ApiFile } from './api-file.decorator';
import { FilesService } from './files.service';
import { ParseFile } from './parse-file.pipe';

@Controller('files')
@ApiTags('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @ApiFile() 
  // üîé ParseFile and throw 400 if file not provided
  uploadFile(@UploadedFile(ParseFile) file: Express.Multer.File) {
    console.log(file);
  }
}
</code></pre>

</div>
<p>That's it for this post. Enjoy uploading your files to Nest! Where are you storing your uploaded files? Drop a comment below if you like</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenAPI for your REST APIs in NestJS]]></title>
        <id>/blog/openapi-in-nestjs</id>
        <link href="https://notiz.dev/blog/openapi-in-nestjs"/>
        <updated>2022-07-27T10:00:00.000Z</updated>
        <summary type="html"><![CDATA[Setup Swagger to generate an OpenAPI documentation for your REST endpoints.]]></summary>
        <content type="html"><![CDATA[<p>The <a href="https://docs.nestjs.com/openapi/introduction">OpenAPI</a> documentation is a useful API playground for you to test or to share with other developers and for client generation tools (e.g <a href="https://github.com/cyclosproject/ng-openapi-gen">ng-openapi-gen for Angular</a>).</p>
<p>You'll find the source code in this repo.</p>
<div shortcode="repo" repo="notiz-dev/nestjs-swagger"></div>
<h2 id="setupswagger">Setup Swagger</h2>
<p>Start with installing the Swagger dependencies.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash"># nest v9
npm install --save @nestjs/swagger class-transformer class-validator

# nest v8
# express
npm install --save @nestjs/swagger@5 swagger-ui-express class-transformer class-validator

# fastify
npm install --save @nestjs/swagger@5 fastify-swagger class-transformer class-validator
</code></pre>

</div>
<p>Now setup the initialization of Swagger in your <code>main.ts</code> file.</p>
<div shortcode="code" tabs="main.ts">
<pre><code class="ts language-ts">import { NestFactory } from '@nestjs/core';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const config = new DocumentBuilder()
    .setTitle('NestJS Swagger')
    .setDescription('API description')
    .setVersion('1.0')
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  await app.listen(3000);
}
bootstrap();
</code></pre>

</div>
<p>The setup is complete, start your Nest application <code>npm run start:dev</code> and visit the Swagger endpoint <a href="http://localhost:3000/api">localhost:3000/api</a>.</p>
<div shortcode="figure" caption="Swagger API after initial setup">

![Swagger API after initial setup](assets/img/blog/openapi-in-nestjs/optimized/swagger-api.png)

</div>
<div shortcode="note">

Swagger API will be available at the path you provide in `SwaggerModule.setup('api',...)` at `http://localhost:3000/api`. Access the JSON file by opening `http://localhost:3000/api-json` for express and `http://localhost:3000/api/json` for fastify.

</div>
<p>Generate in the next step CRUD endpoints for a resource like <strong>users</strong> or <strong>products</strong> and add type definitions for Swagger. </p>
<h2 id="generaterestresource">Generate REST resource</h2>
<p>Use the Nest CLI to <a href="https://trilon.io/blog/introducing-cli-generators-crud-api-in-1-minute#Generating-a-CRUD-API">generate the boilerplate</a> the resource for <strong>users</strong>. </p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">nest generate resource
# short
nest g res

# CLI prompts
? What name would you like to use for this resource (plural, e.g., "users")? users
? What transport layer do you use? REST API
? Would you like to generate CRUD entry points? (Y/n) y
</code></pre>

</div>
<p>You'll find a new <code>users</code> directory under <code>src</code> containing all the boilerplates for your REST endpoints - module, controller, service, entity and dto files.</p>
<p>Start again the Nest application and you should see the new <code>users</code> endpoints in the Swagger API.</p>
<div shortcode="figure" caption="Users endpoints in the Swagger API">

![Users endpoints in the Swagger API](assets/img/blog/openapi-in-nestjs/optimized/users-crud-api.png)

</div>
<h2 id="apidecorators">API decorators</h2>
<p>Apply available <a href="https://docs.nestjs.com/openapi/decorators">decorators prefixed with API</a> to expose the properties for <code>.dto.ts</code> and <code>.entity.ts</code> files and the responses for your CRUD endpoints.</p>
<h3 id="tags">Tags</h3>
<p>Group your endpoints together by using <code>@ApiTags(...tags)</code> at the controller level.</p>
<div shortcode="code" tabs="users.controller.ts">
<pre><code class="ts language-ts">import { Controller } from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';

@Controller('users')
@ApiTags('users') // üëà apply tags
export class UsersController {
  ...
}
</code></pre>

</div>
<div shortcode="figure" caption="Group endpoints with tags">

![Group endpoints with tags](assets/img/blog/openapi-in-nestjs/optimized/users-api-tags.png)

</div>
<h3 id="property">Property</h3>
<p>Let's add the following properties <code>name</code>, <code>email</code>, <code>password</code> to the <code>CreateUserDto</code> and mark name as optional.</p>
<div shortcode="code" tabs="create-user.dto.ts">
<pre><code class="ts language-ts">export class CreateUserDto {
  email: string;
  password: string;
  name?: string |&amp;nbsp;null;
}
</code></pre>

</div>
<p>To expose those <a href="https://docs.nestjs.com/openapi/types-and-parameters">properties</a> to the Swagger API use <code>@ApiProperty(options)</code> at the property level and pass options like <code>required</code>, <code>default</code>, <code>description</code> and more.</p>
<div shortcode="code" tabs="create-user.dto.ts">
<pre><code class="ts language-ts">import { ApiProperty } from '@nestjs/swagger';

export class CreateUserDto {
  @ApiProperty()
  email: string;
  @ApiProperty()
  password: string;
  @ApiProperty({ required: false, nullable: true })
  name?: string |&amp;nbsp;null;
}
</code></pre>

</div>
<p>Refresh the Swagger API and you should see the properties for the <code>CreateUserDto</code>.</p>
<div shortcode="figure" caption="CreateUserDto properties with name optional">

![CreateUserDto properties with name optional](assets/img/blog/openapi-in-nestjs/optimized/createuserdto-properties.png)

</div>
<p>Also have a look at the <code>UpdateUserDto</code> schema in Swagger. The same properties are shown but all of them are marked as optional. This is because of <code>PartialType</code> also called <a href="https://docs.nestjs.com/openapi/mapped-types">Mapped types</a> provided by Nest. </p>
<div shortcode="code" tabs="update-user.dto.ts">
<pre><code class="ts language-ts">import { PartialType } from '@nestjs/swagger';
import { CreateUserDto } from './create-user.dto';

export class UpdateUserDto extends PartialType(CreateUserDto) {}
</code></pre>

</div>
<p><code>PartialType</code> applies the same properties from <code>CreateUserDto</code> but set to optional.</p>
<h3 id="response">Response</h3>
<p>Add the same properties as before to the <code>user.entity.ts</code> and only expose <code>name</code> and <code>email</code> to Swagger.</p>
<div shortcode="code" tabs="user.entity.ts">
<pre><code class="ts language-ts">import { ApiProperty } from '@nestjs/swagger';

export class User {
  @ApiProperty()
  email: string;
  password: string;
  @ApiProperty({ required: false, nullable: true })
  name?: string |&amp;nbsp;null;
}
</code></pre>

</div>
<p>Additionally, Swagger needs help to pick up the response type. Annotate your REST endpoints with the custom <code>@ApiResponse()</code> specifying the status code and the response type or choose a <a href="https://docs.nestjs.com/openapi/operations#responses">short-hand API response</a> (e.g. <code>@ApiOkResponse()</code>, <code>@ApiCreatedResponse()</code>, ‚Ä¶).</p>
<ul>
<li><code>@ApiOkResponse</code>: <code>GET</code> and <code>DELETE</code></li>
<li><code>@ApiCreatedResponse</code>: <code>POST</code> and <code>PATCH</code></li>
<li><code>@ApiForbiddenResponse</code>: endpoint might throw forbidden (<code>403</code>) exception</li>
</ul>
<div shortcode="code" tabs="user.entity.ts">
<pre><code class="ts language-ts">import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { ApiCreatedResponse, ApiOkResponse, ApiTags } from '@nestjs/swagger';
import { User } from './entities/user.entity';

@Controller('users')
@ApiTags('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  @ApiCreatedResponse({ type: User })
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  @ApiOkResponse({ type: [User] }) // üëà array notation
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  @ApiOkResponse({ type: User })
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id);
  }

  @Patch(':id')
  @ApiCreatedResponse({ type: User })
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(+id, updateUserDto);
  }

  @Delete(':id')
  @ApiOkResponse({ type: User })
  remove(@Param('id') id: string) {
    return this.usersService.remove(+id);
  }
}
</code></pre>

</div>
<div shortcode="note">

When the response type is an `array`, you must indicate it using the array bracket notation (`[ ]`) around the `type` or set `isArray` to `true`. `GET /users` response is an array of `User` annotation looks like this:

`@ApiOkResponse({ type: [User] })`

`@ApiOkResponse({ type: User, isArray: true })`

</div>
<p>You'll see the endpoints with the new response type of <code>User</code>.</p>
<div shortcode="figure" caption="CreateUserDto properties with name optional">

![CreateUserDto properties with name optional](assets/img/blog/openapi-in-nestjs/optimized/users-crud-responses.png)

</div>
<h2 id="swaggercliplugin">Swagger CLI Plugin</h2>
<p>Exposing the properties and responses to Swagger results in additional boilerplate. Nest commes with a <a href="https://docs.nestjs.com/openapi/cli-plugin#using-the-cli-plugin">Swagger CLI Plugin</a> to reduce boilerplate in your <code>.dto.ts</code> and <code>.entity.ts</code> files. Enable the plugin in your <code>nest-cli.json</code> file.</p>
<div shortcode="code" tabs="nest-cli.json">
<pre><code class="json language-json">{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "plugins": ["@nestjs/swagger"]
  }
}
</code></pre>

</div>
<p><strong>Before</strong>: <code>User</code> entity, <code>CreateUserDto</code> and <code>UsersController</code> with boilerplate.</p>
<div shortcode="code" tabs="user.entity.ts,create-user.dto.ts,users.controller.ts">
<pre><code class="ts language-ts">export class User {
  @ApiProperty()
  email: string;
  password: string;
  @ApiProperty({ required: false, nullable: true })
  name?: string |&amp;nbsp;null;
}
</code></pre><pre><code class="ts language-ts">import { ApiProperty } from '@nestjs/swagger';

export class CreateUserDto {
  @ApiProperty()
  email: string;
  @ApiProperty()
  password: string;
  @ApiProperty({ required: false, nullable: true })
  name?: string&amp;nbsp;| null;
}
</code></pre><pre><code class="ts language-ts">import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { ApiCreatedResponse, ApiOkResponse, ApiTags } from '@nestjs/swagger';
import { User } from './entities/user.entity';

@Controller('users')
@ApiTags('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  @ApiCreatedResponse({ type: User })
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  @ApiOkResponse({ type: [User] })
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  @ApiOkResponse({ type: User })
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id);
  }

  @Patch(':id')
  @ApiCreatedResponse({ type: User })
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(+id, updateUserDto);
  }

  @Delete(':id')
  @ApiOkResponse({ type: User })
  remove(@Param('id') id: string) {
    return this.usersService.remove(+id);
  }
}
</code></pre>

</div>
<p><strong>After</strong>: CLI plugin enabled and without boilerplate. You need to add <code>@ApiHideProperty</code> otherwise the plugin will also expose the <code>password</code> property.</p>
<div shortcode="code" tabs="user.entity.ts,create-user.dto.ts,users.controller.ts">
<pre><code class="ts language-ts">import { ApiHideProperty } from '@nestjs/swagger';

export class User {
  email: string;
  @ApiHideProperty()
  password: string;
  name?: string | null;
}
</code></pre><pre><code class="ts language-ts">export class CreateUserDto {
  email: string;
  password: string;
  name?: string | null;
}
</code></pre><pre><code class="ts language-ts">import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { ApiTags } from '@nestjs/swagger';
import { User } from './entities/user.entity';

@Controller('users')
@ApiTags('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto): User {
    return this.usersService.create(createUserDto);
  }

  @Get()
  findAll(): User[] {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string): User {
    return this.usersService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto): User {
    return this.usersService.update(+id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string): User {
    return this.usersService.remove(+id);
  }
}
</code></pre>

</div>
<h2 id="advancedswaggertypes">Advanced Swagger Types</h2>
<p>Check out the following posts for type-safe file uploads and download.</p>
<div shortcode="article" routes="/blog/type-safe-file-uploads"></div>
<div shortcode="article" routes="/blog/type-safe-file-downloads"></div>
<p>This allows you to directly test file upload and download in your Swagger documentation and is perfect for client generation tools to pick up the correct input values for the file(s).</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Send Emails with NestJS]]></title>
        <id>/blog/send-emails-with-nestjs</id>
        <link href="https://notiz.dev/blog/send-emails-with-nestjs"/>
        <updated>2022-07-08T10:00:00.000Z</updated>
        <summary type="html"><![CDATA[Create Email Templates and send them with nodemailer from your Nest application]]></summary>
        <content type="html"><![CDATA[<p>This post gets you up and running with everything you need to know about sending Emails using <a href="https://github.com/nest-modules/mailer">nest-modules/mailer</a> in your <a href="https://github.com/nestjs/nest">NestJS</a> backend. üëá</p>
<p>üìß Sending emails using <a href="https://nodemailer.com/about/">Nodemailer</a><br />
üß© Creating email templates with <a href="https://handlebarsjs.com/">handlebars</a> (alternatives: pug or ejs)<br />
‚öôÔ∏è Configure smtp via <code>.env</code> file</p>
<div shortcode="repo" repo="notiz-dev/nestjs-mailer"></div>
<p>If you want to craft beautiful email templates follow the new post</p>
<div shortcode="article" routes="/blog/send-beautiful-emails-crafted-with-maizzle"></div>
<h2 id="installdependencies">Install Dependencies</h2>
<p>Add the <code>@nestjs-modules/mailer</code> and the peer dependency <code>nodemailer</code> to your Nest application. Choose one of the supported template engines for creating your email templates: <a href="https://handlebarsjs.com/">handlebars</a>, <a href="https://pugjs.org/api/getting-started.html">pug</a> or <a href="https://ejs.co/">ejs</a>. </p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm install --save @nestjs-modules/mailer nodemailer
npm install --save-dev @types/nodemailer

# pick one template adapter and install
npm install --save handlebars
# or
npm install --save pug
# or
npm install --save ejs
</code></pre>

</div>
<p>In this guide, you are creating email templates using handlebars. </p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm install --save @nestjs-modules/mailer nodemailer handlebars
npm install --save-dev @types/nodemailer
</code></pre>

</div>
<h2 id="mailmodule">Mail Module</h2>
<p>Let's begin with creating a <code>mail</code> module and service via the Nest CLI and followed by creating a <code>templates</code> folder.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">nest g module mail
nest g service mail

mkdir src/mail/templates
</code></pre>

</div>
<p>Import the <code>MailerModule</code> into your <code>MailModule</code> and configure your mail server transport via <code>smtp</code>. Provide a default <code>from</code> email address to consistently use the same mail throughout your application. No worries, you can always override the default whenever necessary. Last step, configure the templates folder and the adapter in this case <code>HandlebarsAdapter</code>. Find out more about the other template adapters in the <a href="https://nest-modules.github.io/mailer/docs/mailer#configuration">Mailer documentation</a>. </p>
<div shortcode="code" tabs="mail.module.ts">
<pre><code class="ts language-ts">import { MailerModule } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { Module } from '@nestjs/common';
import { MailService } from './mail.service';
import { join } from 'path';

@Module({
  imports: [
    MailerModule.forRoot({
      // transport: 'smtps://user@example.com:topsecret@smtp.example.com',
      // or
      transport: {
        host: 'smtp.example.com',
        secure: false,
        auth: {
          user: 'user@example.com',
          pass: 'topsecret',
        },
      },
      defaults: {
        from: '"No Reply" &lt;noreply@example.com&gt;',
      },
      template: {
        dir: join(__dirname, 'templates'),
        adapter: new HandlebarsAdapter(), // or new PugAdapter() or new EjsAdapter()
        options: {
          strict: true,
        },
      },
    }),
  ],
  providers: [MailService],
  exports: [MailService], // üëà export for DI
})
export class MailModule {}
</code></pre>

</div>
<p>Export the <code>MailService</code> to provide it via Dependency Injection (DI) for your controllers, resolvers and services.</p>
<h2 id="handlebarsmailtemplate">Handlebars Mail Template</h2>
<p>Create your first email template <code>confirmation.hbs</code> in the <code>src/mail/templates</code> folder. Add the following simple template for a user confirmation.</p>
<div shortcode="code" tabs="confirmation.hbs">
<pre><code class="html language-html">&lt;p&gt;Hey {{ name }},&lt;/p&gt;
&lt;p&gt;Please click below to confirm your email&lt;/p&gt;
&lt;p&gt;
    &lt;a href="{{ url }}"&gt;Confirm&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;If you did not request this email you can safely ignore it.&lt;/p&gt;
</code></pre>

</div>
<p>Those curly brackets are <a href="https://handlebarsjs.com/guide/#what-is-handlebars">handlebars expressions</a> and you will provide the <code>context</code> later while sending an email.</p>
<p>When you build your Nest application you will notice that the build output is missing your template files (<code>dist/mail/templates</code>).</p>
<div shortcode="figure" caption="handlebars templates missing in compilation output">

![handlebars templates missing in compilation output](assets/img/blog/send-emails-with-nestjs/optimized/handlebars-templates-missing-in-compilation.png)

</div>
<p>By default, Nest <strong>only</strong> distributes TypeScript compiled files (<code>.js</code> and <code>.d.ts</code>) during the build step. To distribute your <code>.hbs</code> files, open your <code>nest-cli.json</code> and add your <code>templates</code> directory to the <a href="https://docs.nestjs.com/cli/monorepo#assets">assets</a> property in the global <code>compilerOptions</code>.</p>
<div shortcode="code" tabs="nest-cli.json">
<pre><code class="json language-json">{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "assets": ["mail/templates/**/*"], // üëà  or "**/*.hbs" all files ending with .hbs
    "watchAssets": true // ü§ñ copy assets in watch mode
  }
}
</code></pre>

</div>
<p>Build your Nest application again and now your template files are included in the build output.</p>
<div shortcode="figure" caption="handlebars templates included in compilation output">

![handlebars templates included in compilation output](assets/img/blog/send-emails-with-nestjs/optimized/handlebars-templates-included-in-compilation.png)

</div>
<h2 id="sendingmail">Sending Mail</h2>
<p>Add <code>MailerService</code> to your own <code>MailService</code> and implement your mailing logic here. Let's send a user confirmation email using the template <code>confirmation.hbs</code>. You need to provide <code>{{ name }}</code> and <code>{{&amp;nbsp;url }}</code> under the <code>context</code> key. Read the <a href="https://handlebarsjs.com/guide">Handlebars documentation</a> for more background like <a href="https://handlebarsjs.com/guide/#nested-input-objects">Nested input objects</a>.</p>
<div shortcode="code" tabs="mail.service.ts,user.entity.ts">
<pre><code class="ts language-ts">import { MailerService } from '@nestjs-modules/mailer';
import { Injectable } from '@nestjs/common';
import { User } from './../user/user.entity';

@Injectable()
export class MailService {
  constructor(private mailerService: MailerService) {}

  async sendUserConfirmation(user: User, token: string) {
    const url = `example.com/auth/confirm?token=${token}`;

    await this.mailerService.sendMail({
      to: user.email,
      // from: '"Support Team" &lt;support@example.com&gt;', // override default from
      subject: 'Welcome to Nice App! Confirm your Email',
      template: './confirmation', // `.hbs` extension is appended automatically
      context: { // ‚úèÔ∏è filling curly brackets with content
        name: user.name,
        url,
      },
    });
  }
}
</code></pre><pre><code class="ts language-ts">// ./../user/user.entity
export interface User {
  email: string;
  name: string;
}
</code></pre>

</div>
<h2 id="usingmailservice">Using Mail Service</h2>
<p>Add the <code>MailModule</code> to the <code>imports</code> list of your modules which need to use the <code>MailService</code>.</p>
<div shortcode="code" tabs="auth.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { MailModule } from './mail/mail.module';

@Module({
  imports: [MailModule], // üìß
  controllers: [AuthController],
  providers: [AuthService],
})
export class AuthModule {}
</code></pre>

</div>
<p>Now you can add <code>MailService</code> to the constructor of your controllers, resolvers and services</p>
<div shortcode="code" tabs="auth.service.ts">
<pre><code class="ts language-ts">import { Injectable } from '@nestjs/common';
import { MailService } from './../mail/mail.service';
import { User } from './../user/user.entity';

@Injectable()
export class AuthService {
  constructor(private mailService: MailService) {}

  async signUp(user: User) {
    const token = Math.floor(1000 + Math.random() * 9000).toString();
    // create user in db
    // ...
    // send confirmation mail
    await this.mailService.sendUserConfirmation(user, token);
  }
}
</code></pre>

</div>
<h2 id="moveconfigurationstodotenvfile">Move configurations to dotenv file</h2>
<p>Currently, the mail server configurations are hardcoded in to the <code>MailModule</code>. Nest provides a <a href="https://docs.nestjs.com/techniques/configuration">configuration module</a> which enables you to load your configurations and credentials from <code>.env</code> files. </p>
<p>Install the <code>@nestjs/config</code> dependency.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash"># config 
npm i --save @nestjs/config
</code></pre>

</div>
<p>Add the <code>ConfigModule</code> to the <code>imports</code> list of your <code>AppModule</code>.</p>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AuthModule } from './auth/auth.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true, // no need to import into other modules
    }),
    AuthModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</code></pre>

</div>
<p>Create a <code>.env</code> file in your root directory and don't forget to add in your <code>.gitingore</code> file.</p>
<div shortcode="code" tabs=".env">
<pre><code class="bash language-bash"># mail
MAIL_HOST=smtp.example.com
MAIL_USER=user@example.com
MAIL_PASSWORD=topsecret
MAIL_FROM=noreply@example.com

# optional
MAIL_TRANSPORT=smtp://${MAIL_USER}:${MAIL_PASSWORD}@${MAIL_HOST}
</code></pre>

</div>
<p>Reopen <code>MailModule</code> and change <code>MailerModule.forRoot</code> to <code>MailerModule.forRootAsync</code>, this allows you to inject and use the <code>ConfigService</code>.</p>
<div shortcode="code" tabs="mail.module.ts">
<pre><code class="ts language-ts">import { MailerModule } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { Module } from '@nestjs/common';
import { MailService } from './mail.service';
import { join } from 'path';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    MailerModule.forRootAsync({
      // imports: [ConfigModule], // import module if not enabled globally
      useFactory: async (config: ConfigService) =&gt; ({
        // transport: config.get("MAIL_TRANSPORT"),
        // or
        transport: {
          host: config.get('MAIL_HOST'),
          secure: false,
          auth: {
            user: config.get('MAIL_USER'),
            pass: config.get('MAIL_PASSWORD'),
          },
        },
        defaults: {
          from: `"No Reply" &lt;${config.get('MAIL_FROM')}&gt;`,
        },
        template: {
          dir: join(__dirname, 'templates'),
          adapter: new HandlebarsAdapter(),
          options: {
            strict: true,
          },
        },
      }),
      inject: [ConfigService],
    }),
  ],
  providers: [MailService],
  exports: [MailService],
})
export class MailModule {}
</code></pre>

</div>
<p>Time to add your own mail server configuration, start Nest and send your first mails üìß to your users.</p>
<h2 id="globalmailmodule">Global Mail Module</h2>
<p>You might need to send mails throughout the entire Nest application. Make the MailModule a <a href="https://docs.nestjs.com/modules#global-modules">global</a> module by adding the <code>@Global()</code> decorator to <code>MailModule</code> and only import it <strong>once</strong> in your <code>AppModule</code>. All modules can now inject the <code>MailService</code> without forgetting to import the <code>MailModule</code>.</p>
<div shortcode="code" tabs="mail.module.ts">
<pre><code class="ts language-ts">import { MailerModule } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { Global, Module } from '@nestjs/common';
import { MailService } from './mail.service';
import { join } from 'path';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Global() // üëà global module
@Module({
  imports: [
    MailerModule.forRootAsync({
      // imports: [ConfigModule], // import module if not enabled globally
      useFactory: async (config: ConfigService) =&gt; ({
        // transport: config.get("MAIL_TRANSPORT"),
        // or
        transport: {
          host: config.get('MAIL_HOST'),
          secure: false,
          auth: {
            user: config.get('MAIL_USER'),
            pass: config.get('MAIL_PASSWORD'),
          },
        },
        defaults: {
          from: `"No Reply" &lt;${config.get('MAIL_FROM')}&gt;`,
        },
        template: {
          dir: join(__dirname, 'templates'),
          adapter: new HandlebarsAdapter(),
          options: {
            strict: true,
          },
        },
      }),
      inject: [ConfigService],
    }),
  ],
  providers: [MailService],
  exports: [MailService],
})
export class MailModule {}
</code></pre>

</div>
<h2 id="breakingchanges">Breaking Changes</h2>
<p>The latest version of nest-modules/mailer <a href="https://github.com/nest-modules/mailer/releases/tag/v1.6.0">v1.6.0</a> contains a <a href="https://github.com/nest-modules/mailer/issues/550#issuecomment-822249747">breaking change how templates are looked up</a>. </p>
<p>You need to add <code>./</code> to your template names when using v1.6.0, see example below.</p>
<p><div shortcode="code" tabs="mail.service.ts"></p>
<pre><code class="diff language-diff">await this.mailerService.sendMail({
  to: user.email,
  subject: 'Welcome to Nice App! Confirm your Email',
- template: 'confirmation', // ‚ùå template not found in v1.6.0, works fine in v1.5.x
+ template: './confirmation', // ‚úÖ template found again in v1.6.0
  context: { 
    name: user.name,
    url,
  },
});
</code></pre>
<p>&lt;/div</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tailwind CSS Purge: Optimize Angular for Production]]></title>
        <id>/blog/tailwindcss-purge-optimize-angular-for-production</id>
        <link href="https://notiz.dev/blog/tailwindcss-purge-optimize-angular-for-production"/>
        <updated>2020-12-15T09:00:00.000Z</updated>
        <summary type="html"><![CDATA[Remove unused Tailwind CSS utilities from your Angular production build for best performance]]></summary>
        <content type="html"><![CDATA[<p>By design, <a href="https://tailwindcss.com">Tailwind CSS</a> generates a <strong>large amount</strong> of utility classes for your development build. For your Angular application you want the best performance by <strong>only</strong> including the classes you are actually using in your production build. Tailwind got you covered! <a href="https://purgecss.com/">PurgeCSS</a> is build-in making it easy to tree-shake <strong>unused</strong> Tailwind styles for your application.</p>
<p>You are going to learn how to setup Tailwind's <code>purge</code> option to <a href="https://tailwindcss.com/docs/optimizing-for-production">optimize</a> Tailwind CSS in your <a href="/blog/angular-10-with-tailwindcss">Angular</a> and for your <a href="/blog/jamstack-angular-scully-tailwind-css">Scully</a> Jamstack application.</p>
<p>The <code>purge</code> options in this post have been tested with Angular 11 and Tailwind CSS 2.0, it also works with Angular 10 and Tailwind CSS 1.9. </p>
<h2 id="getstarted">Get Started</h2>
<p>Get ready with a new or existing Angular + Tailwind CSS application</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng new app-name

# add tailwind
ng add ngx-tailwind

# optional - add jamstack with Scully
ng add @scullyio/init
</code></pre>

</div>
<p>Now <a href="/blog/angular-10-with-tailwindcss#use-tailwind-css-utility-classes">use Tailwind CSS utility classes</a> in your Angular application HTML template, using <code>apply</code> in your stylesheets or even in your TypeScript files via <code>@HostBinding(...)</code>.</p>
<h2 id="purgeunusedtailwindcssutilitiesinangular">Purge unused Tailwind CSS utilities in Angular</h2>
<p>Tailwind provides a <a href="https://tailwindcss.com/docs/optimizing-for-production#removing-unused-css">purge</a> option in the <code>tailwind.config.js</code> file. Purge removes <strong>only</strong> classes generated by <a href="https://tailwindcss.com/docs/optimizing-for-production#removing-all-unused-styles">Tailwind</a> or styles added to the <code>@layer</code> <a href="https://tailwindcss.com/docs/functions-and-directives#layer">directive</a>. Custom CSS or third-party CSS like Angular Material or Prism.js will not be removed.</p>
<p>Simply provide all your template paths as an array to the <code>purge</code> option. For an Angular application this would be all HTML and TS files in your <code>src</code> directory. TS files should be included as they might reference class names using e.g. <code>@HostBinding(...)</code>.</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">module.exports = {
  purge: ["./src/**/*.html", "./src/**/*.ts"],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>

</div>
<p>Use <code>*.{html,ts}</code> to match multiple file types in the same directory</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="diff language-diff">module.exports = {
- purge: ["./src/**/*.html", "./src/**/*.ts"],
+ purge: ["./src/**/*.{html,ts}"],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>

</div>
<p>Trigger Tailwind to automatically purge your CSS by setting <code>NODE_ENV=production</code> during your <code>ng build</code> step. If you used <a href="https://github.com/notiz-dev/ngx-tailwind">ngx-tailwind</a> schematics to setup Tailwind it automatically added a production script to your <strong>package.json</strong>. Additionally, the latest release of <a href="https://github.com/notiz-dev/ngx-tailwind/releases/tag/v1.1.0">ngx-tailwind@1.1.0</a> adds the above purge options automatically to your <code>tailwind.config.js</code>.</p>
<div shortcode="code" tabs="package.jsoon">
<pre><code class="json language-json">{
  "scripts": {
    "build:prod": "NODE_ENV=production ng build --prod"
  }
}
</code></pre>

</div>
<p>Now run <code>npm run build:prod</code> to <strong>only</strong> include used Tailwind CSS utilities in your Angular production build. This even works great in your Scully application</p>
<h2 id="advancedpurgeoptions">Advanced Purge options</h2>
<p><code>purge</code> also accepts an options object for further optimizations. Available <code>purge</code> options are <a href="https://tailwindcss.com/docs/optimizing-for-production#enabling-manually">enabled</a>, <code>content</code> for your template paths, <a href="https://tailwindcss.com/docs/optimizing-for-production#preserving-html-elements">preserveHtmlElements</a>, <a href="https://tailwindcss.com/docs/optimizing-for-production#purging-specific-layers">layers</a>, <a href="https://tailwindcss.com/docs/optimizing-for-production#purging-specific-layers">mode</a> and last <a href="https://tailwindcss.com/docs/optimizing-for-production#purge-css-options">options</a> to pass it directly to PurgeCSS. The defaults for these options are:</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">module.exports = {
  purge: {
    // enabled: true, // enabled by `NODE_ENV=production` or enable manually
    mode: 'layers', // or 'all' ‚ò†Ô∏è be careful
    preserveHtmlElements: true, // or false ‚ö†Ô∏è not generally recommended
    layers: ['base', 'components', 'utilities'], // remove layers to ignore from purging
    content: [], // add your template paths
    options: { /* PurgeCSS options */}
  },
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>

</div>
<p>Too use the object syntax for the <code>purge</code> option add the template paths to the <code>content</code> option</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">module.exports = {
  purge: {
    content: ["./src/**/*.{html,ts}"]
  },
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>

</div>
<p>Go ahead and provide additional options to the <code>purge</code> object to further optimize your production build based on your application. For specific configurations pass it directly to <a href="https://purgecss.com/configuration.html#options">PurgeCSS</a> using the <code>options</code> key. You can provide <code>safelist</code>, <code>blocklist</code>, <code>extractors</code> and more.</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">module.exports = {
  purge: {
    content: ["./src/**/*.html", "./src/**/*.ts"],

    // These options are passed through directly to PurgeCSS
    options: {
      safelist: ['bg-red-500', /^mat-/],
      blocklist: ['bg-orange-500', /^cdk-/],
      extractors: [],
      ...
    }
  },
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>

</div>
<p>Let's improve purging for a Scully application by writing an <code>extractor</code> for your Markdown content files to detect which HTML tags and CSS classes are <strong>actually</strong> used.</p>
<h2 id="purgescullymarkdowncontent">Purge Scully Markdown content</h2>
<p>Scully organizes the content of your static-site in Markdown files. Add the path to your Markdown files e.g. <code>'./blog/**/*.md'</code> to the <code>content</code> array. Create an <a href="https://purgecss.com/extractors.html#default-extractor">extractor</a> targeting only files with the Markdown extension <code>md</code>.</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">module.exports = {
  purge: {
    content: ['./src/**/*.{html,ts}', './blog/**/*.md'],
    options: {
      extractors: [
        {
          extensions: ['md'],
          extractor: (content) =&gt; {

            return [];
          },
        },
      ],
    },
  },
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>

</div>
<p>Before matching HTML elements and CSS classes you need to parse the Markdown content to HTML. Scully uses <a href="https://github.com/markedjs/marked">marked</a> to parse your Markdown content files. Let's require it in the <code>tailwind.config.js</code> and parse the content in the extractor.</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">const marked = require('marked');

module.exports = {
  purge: {
    content: ['./src/**/*.{html,ts}', './blog/**/*.md'],
    options: {
      extractors: [
        {
          extensions: ['md'],
          extractor: (content) =&gt; {
            content = marked(content);

            return [];
          },
        },
      ],
    },
  },
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>

</div>
<p>Let's use the Regex used by <a href="https://github.com/tailwindlabs/blog.tailwindcss.com/blob/364b3713862b6d309aff79505776a9948ad26620/tailwind.config.js#L5-L27">blog.tailwindcss.com</a> to find all used HTML elements and classes. Also set the <code>mode: 'all'</code> ‚ò†Ô∏è and <code>preserveHtmlElements: false</code> ‚ö†Ô∏è to remove unused tags like <code>h4</code> and more.</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">const marked = require('marked');

module.exports = {
  purge: {
    model: 'all',
    preserveHtmlElements: false,
    content: ['./src/**/*.{html,ts}', './blog/**/*.md'],
    options: {
      extractors: [
        {
          extensions: ['md'],
          extractor: (content) =&gt; {
            content = marked(content);

            // Capture as liberally as possible, including things like `h-(screen-1.5)`
            const broadMatches = content.match(/[^&lt;&gt;"'`\s]*[^&lt;&gt;"'`\s:]/g) || []

            // Capture classes within other delimiters like .block(class="w-1/2") in Pug
            const innerMatches =
              content.match(/[^&lt;&gt;"'`\s.(){}[\]#=%]*[^&lt;&gt;"'`\s.(){}[\]#=%:]/g) || []

            return broadMatches.concat(innerMatches);
          },
        },
      ],
    },
  },
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>

</div>
<p>Perfect, now your Angular or Scully applications are <strong>optimized</strong> for production and you are ready to deploy it to <a href="/blog/firebase-hosting-preview-deploy">Firebase Hosting</a> or other services.</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Firebase Hosting: Preview and Deploy via GitHub Actions]]></title>
        <id>/blog/firebase-hosting-preview-deploy</id>
        <link href="https://notiz.dev/blog/firebase-hosting-preview-deploy"/>
        <updated>2020-11-09T11:58:00.000Z</updated>
        <summary type="html"><![CDATA[Preview and Deploy your Angular or Scully app on Firebase Hosting automated via GitHub Actions]]></summary>
        <content type="html"><![CDATA[<p>You start building an <a href="https://notiz.dev/blog/angular-10-with-tailwindcss">Angular</a> or a <a href="https://notiz.dev/blog/jamstack-angular-scully-tailwind-css">Scully</a> application and at some point you want to invite colleagues, friends, family or customers to check it out. <a href="https://firebase.google.com/docs/hosting/use-cases#what_is_firebase_hosting">Firebase Hosting</a> allows to host your static or dynamic web apps for <strong>FREE</strong> üí∏. You are setting up a GitHub workflow deploying your Scully app (works with Angular and any other web framework) to <strong>preview</strong> and <strong>live</strong> channel. </p>
<p>Demo <a href="https://github.com/notiz-dev/angular-scully-tailwindcss">source code</a> and <a href="https://angular-scully-tailwindcss.web.app/blog">hosted</a> on Firebase üî•.</p>
<p>Before you dive straight into this you will need a</p>
<ul>
<li><a href="https://console.firebase.google.com/">Firebase Account</a></li>
<li><a href="https://github.com/join">GitHub Account</a> and a private or public repo for your web app</li>
</ul>
<p>Use your existing web application or create a new one by following <a href="https://notiz.dev/blog/angular-10-with-tailwindcss">Angular 10 with Tailwind CSS</a> or <a href="https://notiz.dev/blog/jamstack-angular-scully-tailwind-css">Jamstack: Angular + Scully + Tailwind CSS</a> to get started.</p>
<h2 id="gettingstarted">Getting started</h2>
<p>Install <a href="https://firebase.google.com/docs/cli#install_the_firebase_cli">Firebase CLI</a> minimum in <code>v8.12.0</code> for <a href="https://firebase.googleblog.com/2020/10/preview-channels-firebase-hosting.html">preview channels</a> support.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash"># install firebase cli
npm install -g firebase-tools

# init firebase hosting
firebase init hosting
# hosting already setup, prepare GitHub workflow
firebase init hosting:github
</code></pre>

</div>
<p>Follow the CLI prompts to setup Firebase hosting and GitHub workflow.</p>
<div shortcode="figure" caption="Hosting Setup">

![Hosting Setup](assets/img/blog/firebase-hosting-preview-deploy/firebase-hosting-setup.gif)

</div>
<h2 id="firebasehostingsetup">Firebase Hosting Setup</h2>
<p>Start by selecting an <strong>existing</strong> Firebase project, create one in <a href="https://console.firebase.google.com/">Firebase console</a>, or create a <strong>new</strong> project through the CLI.</p>
<p>Next enter the public directory containing all files of your web app including <code>index.html</code> which is uploaded to Firebase hosting</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash"># Angular
dist/&lt;project-name&gt;

# Scully `outDir` specified in your scully.&lt;project-name&gt;.ts defaults to
dist/static
</code></pre>

</div>
<p>You can change the <code>public</code> directory anytime in <code>firebase.json</code> file.</p>
<p>Answer the next question "Configure as a single-page app (rewrite all urls to /index.html)?" with <strong>yes</strong> for Angular apps (and other single-page apps) and <strong>no</strong> for Scully apps (and other static-site apps).</p>
<p>Let Firebase CLI initialize your GitHub repository for <a href="https://firebase.google.com/docs/hosting/github-integration#set-up">automatic deploys</a>. Several steps are taken care by the Firebase CLI for you</p>
<ul>
<li>Creating a Firebase service account with deployment permissions to Firebase Hosting</li>
<li>Encrypt and add secret to GitHub repository</li>
<li>Creating GitHub workflow <code>yaml</code> files</li>
</ul>
<p>Enter <strong>no</strong> for the next two questions to overwrite <code>dist/static/404.html</code> and <code>dist/static/index.html</code>, let those be generated by Scully.</p>
<p>Select a GitHub repository to setup your secret token for your workflow and enter a build script to build Angular and Scully like <code>npm ci &amp;&amp; npm run build:ci</code>. For a Scully build add the following two scripts to your <code>package.json</code>:</p>
<div shortcode="code" tabs="package.json">
<pre><code class="json language-json">"build:ci": "npm run build:prod &amp;&amp; npm run scully:ci"
"scully:ci": "scully -- --host='0.0.0.0' --scanRoutes --serverTimeout=60000",
</code></pre>

</div>
<p>If you like to deploy to live channel on merged Pull Request answer with <strong>yes</strong> and enter your branch name for the live channel for example <code>main</code>. </p>
<h2 id="githubworkflow">GitHub Workflow</h2>
<p>You should have now two workflows if you used the Firebase CLI. The workflows use the GitHub Action <a href="https://github.com/marketplace/actions/deploy-to-firebase-hosting">Deploy to Firebase Hosting</a>, currently in <strong>alpha</strong> release.</p>
<p>Workflow to deploy to a preview channel on Pull Request <code>.github/workflows/firebase-hosting-pull-request.yml</code></p>
<div shortcode="code" tabs="firebase-hosting-pull-request.yml">
<pre><code class="yaml language-yaml"># This file was auto-generated by the Firebase CLI
# https://github.com/firebase/firebase-tools

name: Deploy to Firebase Hosting on PR
'on': pull_request
jobs:
  build_and_preview:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: 'npm ci &amp;&amp; npm run build:ci'
      # Add additional build steps here
      # - run: ...
      - uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
          projectId: your-firebase-project-id
          # default expire value 7 days
          # expires: 7d
        env:
          FIREBASE_CLI_PREVIEWS: hostingchannels
</code></pre>

</div>
<p>Workflow to deploy to your live channel on push to <code>main</code> branch <code>.github/workflows/firebase-hosting-merge.yml</code></p>
<div shortcode="code" tabs="firebase-hosting-merge.yml">
<pre><code class="yaml language-yaml"># This file was auto-generated by the Firebase CLI
# https://github.com/firebase/firebase-tools

name: Deploy to Firebase Hosting on merge
'on':
  push:
    branches:
      - main
jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: 'npm ci &amp;&amp; npm run build:ci'
      # Add additional build steps here
      # - run: ...
      - uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
          channelId: live
          projectId: your-firebase-project-id
        env:
          FIREBASE_CLI_PREVIEWS: hostingchannels
</code></pre>

</div>
<p>Deploying to the live channel requires <code>channelId</code> set to <code>live</code>. If left blank the action creates a new preview channel using the PR-branch name. </p>
<p>Additional option for the preview channel is <code>expires</code> which defaults to 7 days. Change the <a href="https://firebase.google.com/docs/hosting/manage-hosting-resources#preview-channel-expiration">expiration</a> of your preview channel to maximum 30 days. It supports the syntax <code>h</code> for hours, <code>d</code> for days and <code>w</code> for weeks, for example <code>19h</code>, <code>30d</code>, <code>3w</code>.</p>
<h2 id="previewandlivechannel">Preview and Live Channel</h2>
<p>Create a Pull Request with the above GitHub workflows and you should see the GitHub Action start building</p>
<div shortcode="figure" caption="GitHub Action run on Pull Request">

![GitHub Action run on Pull Request](assets/img/blog/firebase-hosting-preview-deploy/optimized/github-action-pull-request-building.png)

</div>
<p>After the workflow finished successfully, the Firebase action creates a comment with the preview URL for this PR.</p>
<div shortcode="figure" caption="Preview URL created by Firebase Action">

![Preview URL created by Firebase Action](assets/img/blog/firebase-hosting-preview-deploy/optimized/preview-url-created-by-firebase-action.png)

</div>
<p>View the preview of your web app, if you are not happy with your changes repeat it. Here is the Scully demo blog in the preview channel on Firebase Hosting.</p>
<div shortcode="figure" caption="Preview on Firebase Hosting">

![Preview URL created by Firebase Action](assets/img/blog/firebase-hosting-preview-deploy/optimized/scully-preview-on-firebase-hosting.png)

</div>
<p>Finally, merge your Pull Request to trigger the deployment to the live channel. Find the <a href="https://angular-scully-tailwindcss.web.app/blog">Scully demo blog</a> on the live channel.</p>
<p>It was never easier to ship improvements to your web application to preview, ask colleagues or customers for a review üëå‚ùì and simply deploy your changes to the live channel üöÄ by merging your PR. </p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jamstack: Angular + Scully + Tailwind CSS]]></title>
        <id>/blog/jamstack-angular-scully-tailwind-css</id>
        <link href="https://notiz.dev/blog/jamstack-angular-scully-tailwind-css"/>
        <updated>2020-10-29T15:20:00.000Z</updated>
        <summary type="html"><![CDATA[Use Angular's static site generator Scully and style it with Tailwind CSS]]></summary>
        <content type="html"><![CDATA[<p><a href="https://scully.io/">Scully</a> is a static site generator build for the web framework <a href="https://angular.io/">Angular</a>. You learn how to build a <a href="https://jamstack.org/what-is-jamstack/">Jamstack</a> project with Angular and Scully. Let's add <a href="https://tailwindcss.com">Tailwind CSS</a> for easy styling, the cherry üçí  on the cake üç∞.</p>
<h2 id="tldr">TL;DR</h2>
<p>Create a new Angular project, add Scully and Tailwind CSS using schematics. Angular provides <a href="https://angular.io/guide/schematics">schematics</a> for generating and performing installation steps automatically for you - used by Scully and <a href="https://github.com/notiz-dev/ngx-tailwind">ngx-tailwind</a>. üíØ</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng new app-name --style=scss --routing true
cd app-name

# add scully
ng add @scullyio/init

# add scully blog
ng generate @scullyio/init:blog

# add tailwind
ng add ngx-tailwind
</code></pre>

</div>
<p>Or follow along with the <a href="https://github.com/notiz-dev/angular-scully-tailwindcss">source code</a>.
For more information about Angular and Tailwind read the in-depth guide <a href="https://notiz.dev/blog/angular-10-with-tailwindcss">Angular 10 with Tailwind CSS</a>.</p>
<h2 id="removeunusedcssforproductionbuild">Remove unused CSS for production build üßπ</h2>
<p>Tailwind generates a lot of CSS styles which are very helpful during development. Before deploying the Scully app <a href="https://tailwindcss.com/docs/controlling-file-size#removing-unused-css">remove all unused CSS</a> using the <code>purge</code> option in <code>tailwind.config.js</code>. Provide paths of your template and TypeScript files:</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="diff language-diff">module.exports = {
  future: {
    // removeDeprecatedGapUtilities: true,
    // purgeLayersByDefault: true,
  },
+ purge: ["./src/**/*.html", "./src/**/*.ts"],
  theme: {
    extend: {},
  },
  variants: {},
  plugins: [],
};
</code></pre>

</div>
<p>Tailwind automatically purges unused styles when <code>NODE_ENV</code> is set to <code>production</code>. Use the script added by <code>ngx-tailwind</code></p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run build:prod
</code></pre>

</div>
<p>Open <code>app.component.html</code> and add a <code>header</code> template using Tailwind utility styles.</p>
<div shortcode="code" tabs="app.component.html">
<pre><code class="html language-html">&lt;div class="max-w-3xl mx-auto px-4 sm:px-6 xl:max-w-5xl xl:px-0"&gt;
  &lt;header class="flex justify-between items-center py-10"&gt;
    &lt;div&gt;
      &lt;a href="/" class="text-xl font-semibold"&gt; Angular + Scully + Tailwind = üöÄ &lt;/a&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;a href="https://github.com/notiz-dev/angular-scully-tailwindcss" class="font-medium text-gray-500 hover:text-gray-700"&gt; Source Code &amp;rarr; &lt;/a&gt;
    &lt;/div&gt;
  &lt;/header&gt;

  &lt;main&gt;
    &lt;!-- Displaying Angular routes --&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  &lt;/main&gt;
&lt;/div&gt;
</code></pre>

</div>
<p>Customize your own header on <a href="https://play.tailwindcss.com/CyNMJvURiy">play.tailwindcss.com</a>.</p>
<h2 id="startscully">Start Scully</h2>
<p>Getting started to serve Angular as a Jamstack app for the first time. Follow the steps in this order.</p>
<p>First build Angular app</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run build:prod
</code></pre>

</div>
<p>Build Scully app</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run scully
</code></pre>

</div>
<p>All pre-rendered static  site files are generated in <code>./dist/static</code>. For each page you will see an <code>index.html</code> file.</p>
<p>Scully app</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run scully:serve
</code></pre>

</div>
<p>Open your favorite browser and go to <a href="http://localhost:1668/">http://localhost:1668/</a> for the Scully static server and <a href="http://localhost:1864/">http://localhost:1864/</a> for the Angular server.</p>
<p>You should see on both links - Angular top üëÜ, Scully bottom üëá.</p>
<div shortcode="figure" caption="First Scully Serve">

![First Scully Serve](assets/img/blog/jamstack-angular-scully-tailwind-css/optimized/first-scully-serve.png)

</div>
<h2 id="whatsaddedbyscully">What's added by Scully? üîç</h2>
<p>Scully creates a <a href="https://scully.io/docs/reference/config/">config</a> file <code>scully.&lt;projectname&gt;.config.ts</code> at the root folder. You will look at this in a moment.</p>
<p>Additionally, after your first Scully build new few new files are generated by Scully. Let's add those to the <code>.gitignore</code> file</p>
<div shortcode="code" tabs=".gitignore">
<pre><code class="bash language-bash"># Scully
.scully
scully.log
src/assets/scully-routes.json
scully/plugins/*.js
scully/plugins/*.js.map
</code></pre>

</div>
<p><code>scully-routes.json</code> contains all information about your available routes including the front matter data which you will access later in your blog post page.</p>
<h2 id="markdownblog">Markdown blog</h2>
<p>One üíç command to rule your blog</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng generate @scullyio/init:blog
</code></pre>

</div>
<p>Do you need more flexibility? Try running the following and answer a few <a href="https://scully.io/docs/learn/create-a-blog/add-blog-support/#available-options">questions</a>:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng generate @scullyio/init:markdown
</code></pre>

</div>
<p>Now your blog is setup. A new route like <code>/blog/&lt;slug&gt;</code> has been added, re-build your Angular app and discover the new route with Scully</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run scully -- --scanRoutes
</code></pre>

</div>
<p>Serve your Scully app and navigate to the first generated post in your browser <code>localhost:1668/blog/&lt;slug&gt;</code>.</p>
<div shortcode="figure" caption="First Scully Blog Post">

![First Scully Blog Post](assets/img/blog/jamstack-angular-scully-tailwind-css/optimized/first-scully-blog-post.png)

</div>
<p>Scully creates for each blog post an <code>index.html</code> inside your <code>dist/static/blog</code> directory.</p>
<div shortcode="figure" caption="Scully Static Directory with unpublished post">

![Scully Static Directory with unpublished post](assets/img/blog/jamstack-angular-scully-tailwind-css/optimized/scully-build-with-unpublished-post.png)

</div>
<h2 id="styleblogpostpage">Style blog post page</h2>
<p>Alright, you got your first blog post page rendered, but let's be honest üßê it needs a few adjustment. The current blog post page is missing the <strong>blog post title</strong>, <strong>publishing date</strong> and has <strong>unstyled</strong> content. </p>
<p>Scully has a build in service <code>ScullyRoutesService</code> to access the front matter of your blog posts. It exposes all published posts under <code>ScullyRoutesService.available$</code> and the current page with <code>ScullyRoutesService.getCurrent()</code>.</p>
<p>Open your generated <code>blog.component.ts</code> and use <code>ScullyRoutesService.getCurrent()</code></p>
<div shortcode="code" tabs="blog.component.ts">
<pre><code class="ts language-ts">import { Component, OnInit, ViewEncapsulation } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { ScullyRoute, ScullyRoutesService } from '@scullyio/ng-lib';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-blog',
  templateUrl: './blog.component.html',
  styleUrls: ['./blog.component.scss'],
  preserveWhitespaces: true,
  encapsulation: ViewEncapsulation.Emulated,
})
export class BlogComponent implements OnInit {
  currentPost$: Observable&lt;ScullyRoute&gt; = this.scully.getCurrent();

  constructor(
    private router: Router,
    private route: ActivatedRoute,
    private scully: ScullyRoutesService
  ) {}

  ngOnInit() {}
}
</code></pre>

</div>
<p>In your template use <code>async</code> pipe to unwrap the <code>Observable</code> to access the <code>title</code> and <code>publishedAt</code> (custom property).</p>
<div shortcode="code" tabs="blog.component.html">
<pre><code class="html language-html">&lt;article&gt;
  &lt;header *ngIf="currentPost$ | async as currentPost" class="pt-6 xl:pb-10"&gt;
    &lt;div class="space-y-1 text-center"&gt;
      &lt;dl class="space-y-10" *ngIf="currentPost.publishedAt"&gt;
        &lt;div&gt;
          &lt;dt class="sr-only"&gt;Published on&lt;/dt&gt;
          &lt;dd class="text-base leading-6 font-medium text-gray-500"&gt;
            &lt;time [dateTime]="currentPost.publishedAt"&gt; {{ currentPost.publishedAt | date: "dd MMMM yyyy" }} &lt;/time&gt;
          &lt;/dd&gt;
        &lt;/div&gt;
      &lt;/dl&gt;
      &lt;div&gt;
        &lt;h1 class="text-3xl leading-9 font-extrabold text-gray-900 tracking-tight sm:text-4xl sm:leading-10 md:text-5xl md:leading-14"&gt;{{ currentPost.title }}&lt;/h1&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/header&gt;

  &lt;!-- This is where Scully will inject the static HTML --&gt;
  &lt;scully-content&gt;&lt;/scully-content&gt;
&lt;/article&gt;
</code></pre>

</div>
<p>Check out <a href="https://blog.tailwindcss.com/">Tailwind Blog</a> which is used here as reference for styling a simple and clean blog.</p>
<p>Update your blog front matter to set <code>published</code> to <code>true</code>, add <code>publishedAt</code> with a datetime string and remove any unpublished <code>slug</code>, also add some placeholder content:</p>
<pre lang="md"><code class="language-markdown">---
title: 2020-10-23-blog
description: 10 Top tips about your next Pizza Hawaii
published: true
publishedAt: 2020-10-31T13:37:00.000Z
---

# Pizza üçï

Eat **pizza** hawaii *everyday*. ~~Don't forget~~ the üßÄ on your `pizza`.

```
var pizza = "Eat üçï";
alert(pizza);
```

## Hawaii

Ordered List

1. üçç
2. ü•ì
3. üßÄ

Unordered List

* üßÄ
* üçç
* ü•ì

### Diavolo

&gt; Pizza might be very üå∂Ô∏è
</code></pre>
<p>Last but not least, remove all styles from <code>blog.component.scss</code>. Now re-build Angular, Scully and serve Scully to see the new blog post header</p>
<div shortcode="figure" caption="Scully blog post header with title and published date">

![Scully blog post header with title and published date](assets/img/blog/jamstack-angular-scully-tailwind-css/optimized/scully-post-with-header.png)

</div>
<p>Awesome ü§© looks much better. What about the unstyled content? ü§® Go and install <a href="https://github.com/tailwindlabs/tailwindcss-typography#installation">Tailwind Typography</a> plugin applying styles to your markdown content.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm install -D @tailwindcss/typography
</code></pre>

</div>
<p>Add the plugin to your <code>tailwind.config.js</code> </p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">module.exports = {
  future: {
    // removeDeprecatedGapUtilities: true,
    // purgeLayersByDefault: true,
  },
  purge: ["./src/**/*.html", "./src/**/*.ts"],
  theme: {
    extend: {},
  },
  variants: {},
  plugins: [require('@tailwindcss/typography')],
};
</code></pre>

</div>
<p>Now wrap <code>&lt;scully-content&gt;&lt;/scully-content&gt;</code> with the <code>prose</code> class provided by the Tailwind Typography plugin:</p>
<div shortcode="code" tabs="blog.component.html">
<pre><code class="html language-html">&lt;article&gt;
  &lt;header&gt;
    ...
  &lt;/header&gt;

  &lt;div class="prose max-w-none pt-10 pb-8"&gt;
    &lt;!-- This is where Scully will inject the static HTML --&gt;
    &lt;scully-content&gt;&lt;/scully-content&gt;
  &lt;/div&gt;
&lt;/article&gt;
</code></pre>

</div>
<p>Blog post content is now styled üòé. How easy was that? Feel free to further <a href="https://github.com/tailwindlabs/tailwindcss-typography#customization">customize</a> the styles to your brand or personal style.</p>
<div shortcode="figure" caption="Prose markdown content using Tailwind Typography plugin"><p><img src="assets/img/blog/jamstack-angular-scully-tailwind-css/optimized/scully-typography-prose-content.png" alt="Prose markdown content using Tailwind Typography plugin" /></p></div>
<p>One more thing is left, listing all available posts and navigating to the post slug.</p>
<h2 id="blogoverviewpage">Blog Overview Page</h2>
<p>Generate a new component for your route <code>/blog</code> displaying all available posts using <code>ScullyRoutesService.available$</code>.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng g module blogs --route blogs --module blog/blog.module
</code></pre>

</div>
<p>Change the path of your new route in <code>blog-routing.module.ts</code> from <code>blogs</code> to empty to match the <code>/blog</code> route.</p>
<div shortcode="code" tabs="blog-routing.module.ts">
<pre><code class="diff language-diff">const routes: Routes = [
  {
+   path: '',
-   path: 'blogs',
    loadChildren: () =&gt;
      import('../blogs/blogs.module').then((m) =&gt; m.BlogsModule),
  },
  {
    path: ':slug',
    component: BlogComponent,
  },
  {
    path: '**',
    component: BlogComponent,
  },
];
</code></pre>

</div>
<p>If you like to automatically redirect to <code>/blog</code> open <code>app-routing.module.ts</code></p>
<div shortcode="code" tabs="app-routing.module.ts">
<pre><code class="diff language-diff">const routes: Routes = [
+ { path: '', redirectTo: 'blog', pathMatch: 'full' },
  {
    path: 'blog',
    loadChildren: () =&gt; import('./blog/blog.module').then((m) =&gt; m.BlogModule),
  },
];
</code></pre>

</div>
<p>Now create a reference for all available blog posts in <code>blogs.component.ts</code> filtering out pages with routes starting only with <code>/blog/</code>. Additionally, sort your posts in descending order by the <code>publishedAt</code> date.</p>
<div shortcode="code" tabs="blogs.component.ts">
<pre><code class="ts language-ts">import { Observable } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import { Component, OnInit } from '@angular/core';
import { ScullyRoute, ScullyRoutesService } from '@scullyio/ng-lib';

@Component({
  selector: 'app-blogs',
  templateUrl: './blogs.component.html',
  styleUrls: ['./blogs.component.scss'],
})
export class BlogsComponent implements OnInit {
  available$: Observable&lt;ScullyRoute[]&gt;;

  constructor(private scully: ScullyRoutesService) {}

  ngOnInit(): void {
    this.available$ = this.scully.available$.pipe(
      map((r) =&gt; r.filter((page) =&gt; page.route.startsWith('/blog/'))),
      map((r) =&gt; r.sort((page1, page2) =&gt; new Date(page2.publishedAt).getTime() - new Date(page1.publishedAt).getTime()))
    );
  }
}
</code></pre>

</div>
<p>Important to note you have to import <code>ScullyLibModule</code> in your <code>blogs.module.ts</code> to access <code>ScullyRoutesService</code>.</p>
<p>Add your blog name and loop over all posts in your template</p>
<div shortcode="code" tabs="blogs.component.html">
<pre><code class="html language-html">&lt;div class="pt-6 pb-8 space-y-2 md:space-y-4"&gt;
  &lt;h1 class="text-3xl font-extrabold bg-clip-text text-transparent bg-gradient-to-r from-orange-500 via-yellow-400 to-yellow-200 tracking-tight sm:text-4xl md:text-6xl"&gt;Company Blog&lt;/h1&gt;
  &lt;p class="text-lg leading-7 text-gray-500"&gt;All the latest Company news.&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="divide-y divide-gray-200"&gt;
  &lt;li *ngFor="let post of available$ | async" class="py-12"&gt;
    &lt;article class="space-y-2 xl:grid xl:grid-cols-4 xl:space-y-0 xl:items-baseline"&gt;
      &lt;dl&gt;
        &lt;dt class="sr-only"&gt;Published on&lt;/dt&gt;
        &lt;dd class="text-base leading-6 font-medium text-gray-500"&gt;
          &lt;time [dateTime]="post.publishedAt"&gt; {{ post.publishedAt | date: "dd MMMM yyyy" }} &lt;/time&gt;
        &lt;/dd&gt;
      &lt;/dl&gt;
      &lt;div class="space-y-4 xl:col-span-3"&gt;
        &lt;div class="space-y-6"&gt;
          &lt;h2 class="text-2xl leading-8 font-bold tracking-tight"&gt;
            &lt;a [routerLink]="post.route" class="text-gray-900 hover:text-gray-700"&gt; {{ post.title }} &lt;/a&gt;
          &lt;/h2&gt;
          &lt;div class="prose max-w-none text-gray-500"&gt;{{ post.description }}&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="text-base leading-6 font-medium"&gt;
          &lt;a [routerLink]="post.route" class="text-orange-500 hover:text-orange-600"&gt; Read more &amp;rarr; &lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/article&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

</div>
<div shortcode="figure" caption="Blog overview page">

![Blog overview page](assets/img/blog/jamstack-angular-scully-tailwind-css/optimized/blog-post-overview-page.png)

</div>
<p>Now all you need is an idea and time to write it down. <a href="https://scully.io/docs/learn/create-a-blog/generate-new-blog-posts/">Creating</a> your next blog post is as easy as üíÜ</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng generate @scullyio/init:post --name="Cool post"
</code></pre>

</div>
<p>Made possible by Scully schematics.</p>
<p>What are you wait for? üòÑ Now it's time for you to create your own blog üöÄ. Need more inspiration? <a href="https://notiz.dev">notiz.dev</a> is build using Scully and Tailwind CSS. üòâ </p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DBML generator for Prisma]]></title>
        <id>/blog/prisma-dbml-generator</id>
        <link href="https://notiz.dev/blog/prisma-dbml-generator"/>
        <updated>2020-09-18T13:30:00.000Z</updated>
        <summary type="html"><![CDATA[Visualize Prisma Schema as Entity-Relationship Diagram]]></summary>
        <content type="html"><![CDATA[<p>Introducing ü•≥ <a href="https://github.com/notiz-dev/prisma-dbml-generator">Prisma DBML Generator</a> <strong>automatically</strong> generating a <a href="https://www.dbml.org/home">DBML</a> schema based on your Prisma Schema. </p>
<div shortcode="repo" repo="notiz-dev/prisma-dbml-generator"></div>
<h2 id="dbmlgenerator">DBML Generator</h2>
<p>Simply install the DBML generator</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm install -D prisma-dbml-generator
</code></pre>

</div>
<p>Add the generator to your <code>schema.prisma</code></p>
<div shortcode="code" tabs="schema.prisma">
<pre><code class="prisma language-prisma">generator dbml {
  provider = "prisma-dbml-generator"
}
</code></pre>

</div>
<p>Running <code>npx prisma generate</code> for the following Prisma schema</p>
<div shortcode="code" tabs="schema.prisma">
<pre><code class="prisma language-prisma">model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String   @unique
  name      String?
  posts     Post[]
  profile   Profile?
  /// user role
  role      Role     @default(USER)
}

/// User profile
model Profile {
  id     Int     @default(autoincrement()) @id
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model Post {
  id         Int        @id @default(autoincrement())
  title      String     @default("")
  content    String?
  published  Boolean    @default(false)
  author     User?      @relation(fields: [authorId], references: [id])
  authorId   Int?
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

/// user role
enum Role {
  ADMIN /// allowed to do everything
  USER
}
</code></pre>

</div>
<p>generates the following <code>schema.dbml</code> to <code>prisma/dbml</code></p>
<div shortcode="code" tabs="schema.dbml">
<pre><code class="dbml language-dbml">Table User {
  id Int [pk, increment]
  createdAt DateTime [default: `now()`, not null]
  updatedAt DateTime [not null]
  email String [unique, not null]
  name String
  posts Post
  profile Profile
  role Role [not null, default: 'USER', note: 'user role']
}

Table Profile {
  id Int [pk, increment]
  bio String
  user User [not null]
  userId Int [unique, not null]

  Note: 'User profile'
}

Table Post {
  id Int [pk, increment]
  title String [not null, default: '']
  content String
  published Boolean [not null, default: false]
  author User
  authorId Int
  categories Category
}

Table Category {
  id Int [pk, increment]
  name String [not null]
  posts Post
}

Table CategoryToPost {
  categoryId Int [ref: &gt; Category.id]
  postId Int [ref: &gt; Post.id]
}

Enum Role {
  ADMIN
  USER
}

Ref: Profile.userId - User.id

Ref: Post.authorId &gt; User.id
</code></pre>

</div>
<p>Copy the <code>schema.dbml</code> content and <a href="https://dbdiagram.io/d">visualize</a> it as an Entity-Relationship Diagram:</p>
<div shortcode="figure" caption="Entity-Relationship Diagram">

![Entity-Relationship Diagram](assets/img/blog/prisma-dbml-generator/optimized/db-diagram.png)

</div>
<p>You should see this output each time you run <code>npx prisma generate</code></p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">$ npx prisma generate
Environment variables loaded from prisma/.env

‚úî Generated Prisma Client to ./node_modules/@prisma/client in 281ms

‚úî Generated DBML Schema to ./prisma/dbml in 5ms

You can now start using Prisma Client in your code:

``
import { PrismaClient } from '@prisma/client'
// or const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()
``

Explore the full API: http://pris.ly/d/client
</code></pre>

</div>
<h2 id="additionaloptions">Additional Options</h2>
<p>Do you like to configure the output directory or even the output name ü§ì?
You can play around with the following options:</p>
<div shortcode="code" tabs="schema.prisma">
<pre><code class="prisma language-prisma">generator dbml {
  provider   = "prisma-dbml-generator"
  output     = "../dbml"
  outputName = "awesome.dbml"
}
</code></pre>

</div>
<p><a href="https://github.com/notiz-dev/prisma-dbml-generator#additional-options">Check out all options</a> and give it a try with your own Prisma Schema üòé.</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introducing NestJS Prisma Library and Schematics]]></title>
        <id>/blog/nestjs-prisma-schematics</id>
        <link href="https://notiz.dev/blog/nestjs-prisma-schematics"/>
        <updated>2022-09-12T14:25:00.000Z</updated>
        <summary type="html"><![CDATA[Library and schematics to add Prisma integration to a NestJS application]]></summary>
        <content type="html"><![CDATA[<p>Until now, adding <a href="https://notiz.dev/blog/how-to-connect-nestjs-with-prisma">Prisma to a NestJS application</a> requires a few manual steps - installing <a href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-cli/command-reference">@prisma/cli</a> and <a href="https://github.com/prisma/prisma-client-js">@prisma/client</a>, creating a <code>PrismaService</code> and (eventually) adding a <code>Dockerfile</code>.</p>
<p>We are excited to release <a href="https://nestjs-prisma.dev">nestjs-prisma</a> - a library with build-in <code>PrismaService</code>, <code>PrismaClientExceptionFilter</code>, <code>loggingMiddleware</code> and a set of schematics to perform <strong>automatically</strong> all steps necessary to add Prisma to your NestJS application. </p>
<div shortcode="repo" repo="notiz-dev/nestjs-prisma"></div>
<h2 id="schematics">Schematics</h2>
<p>All you need to do is run the following command in your Nest app:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">nest add nestjs-prisma
</code></pre>

</div>
<div shortcode="figure" caption="Schematics in action">

![Schematics in action](assets/img/blog/nestjs-prisma-schematics/schematics-in-action.gif)

</div>
<h2 id="library">Library</h2>
<p>Since version <a href="https://github.com/notiz-dev/nestjs-prisma/releases/tag/v0.6.0">0.6.0</a> the package <code>nestjs-prisma</code> is also a library providing <code>PrismaService</code>, <code>PrismaModule</code> and <code>PrismaClientExceptionFilter</code> (<a href="https://github.com/notiz-dev/nestjs-prisma/releases/tag/v0.13.0">0.13.0</a>).</p>
<h3 id="prismamoduleandprismaservice">PrismaModule and PrismaService</h3>
<p>Add <code>PrismaModule</code> to the imports section in your <code>AppModule</code> or any other modules to gain access to <code>PrismaService</code>.</p>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { PrismaModule } from 'nestjs-prisma';

@Module({
  imports: [PrismaModule.forRoot()],
})
export class AppModule {}
</code></pre>

</div>
<p><code>PrismaModule</code> allows to be used globally and to pass options to the <code>PrismaClient</code>.</p>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { PrismaModule } from 'nestjs-prisma';

@Module({
  imports: [
    PrismaModule.forRoot({
      isGlobal: true,
      prismaServiceOptions: {
        prismaOptions: { log: ['info'] },
        explicitConnect: true,
      },
    }),
  ],
})
export class AppModule {}
</code></pre>

</div>
<p>Additionally, <code>PrismaModule</code> provides a <code>forRootAsync</code> to pass options asynchronously. One option is to use a factory function:</p>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { PrismaModule } from 'nestjs-prisma';

@Module({
  imports: [
    PrismaModule.forRootAsync({
      isGlobal: true,
      useFactory: () =&gt; ({
        prismaOptions: {
          log: ['info', 'query'],
        },
        explicitConnect: false,
      }),
    }),
  ],
})
export class AppModule {}
</code></pre>

</div>
<p>You can inject dependencies such as <code>ConfigModule</code> to load options from .env files.</p>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { PrismaModule } from 'nestjs-prisma';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    PrismaModule.forRootAsync({
      isGlobal: true,
      useFactory: async (configService: ConfigService) =&gt; {
        return {
          prismaOptions: {
            log: [configService.get('log')],
            datasources: {
              db: {
                url: configService.get('DATABASE_URL'),
              },
            },
          },
          explicitConnect: configService.get('explicit'),
        };
      },
      inject: [ConfigService],
    }),
  ],
})
export class AppModule {}
</code></pre>

</div>
<p>Alternatively, you can use a class instead of a factory:</p>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { PrismaModule } from 'nestjs-prisma';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    PrismaModule.forRootAsync({
      isGlobal: true,
      useClass: PrismaConfigService,
    }),
  ],
})
export class AppModule {}
</code></pre>

</div>
<p>Create the <code>PrismaConfigService</code> and extend it with the <code>PrismaOptionsFactory</code></p>
<div shortcode="code" tabs="prisma-config.service.ts">
<pre><code class="ts language-ts">import { Injectable } from '@nestjs/common';
import { PrismaOptionsFactory, PrismaServiceOptions } from '.nestjs-prisma';

@Injectable()
export class PrismaConfigService implements PrismaOptionsFactory {
  constructor() {
    // TODO inject any other service here like the `ConfigService`
  }

  createPrismaOptions(): PrismaServiceOptions | Promise&lt;PrismaServiceOptions&gt; {
    return {
      prismaOptions: {
        log: ['info', 'query'],
      },
      explicitConnect: true,
    };
  }
}
</code></pre>

</div>
<h3 id="prismaclientexceptionfilter">PrismaClientExceptionFilter</h3>
<p><code>nestjs-prisma</code> provides a <code>PrismaClientExceptionFilter</code> to catch unhandled <a href="https://www.prisma.io/docs/reference/api-reference/error-reference#prisma-client-query-engine">PrismaClientKnownRequestError</a> and returning different status codes instead of <code>500 Internal server error</code>.</p>
<p>To use the filter you have the following two options.</p>
<ol>
<li>Instantiate the filter in your <code>main.ts</code> and pass the <code>HttpAdapterHost</code></li>
</ol>
<div shortcode="code" tabs="main.ts">
<pre><code class="ts language-ts">import { ValidationPipe } from '@nestjs/common';
import { HttpAdapterHost, NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { PrismaClientExceptionFilter } from 'nestjs-prisma';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const { httpAdapter } = app.get(HttpAdapterHost);
  app.useGlobalFilters(new PrismaClientExceptionFilter(httpAdapter));

  await app.listen(3000);
}
bootstrap();
</code></pre>

</div>
<ol start="2">
<li>Use <code>APP_FILTER</code> token in any module</li>
</ol>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { APP_FILTER } from '@nestjs/core';
import { PrismaClientExceptionFilter } from 'nestjs-prisma';

@Module({
  providers: [
    {
      provide: APP_FILTER,
      useClass: PrismaClientExceptionFilter,
    },
  ],
})
export class AppModule {}
</code></pre>

</div>
<h2 id="additionaloptions">Additional Options</h2>
<p>Do you need more options? I got you covered, you can go a step further and specify a Prisma version if you like:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">nest add nestjs-prisma --prismaVersion 2.4.1
</code></pre>

</div>
<p>Or go crazy by adding a <code>Dockerfile</code> for your Nest app and a <code>docker-compose.yaml</code> with a <strong>PostgreSQL</strong> database.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">nest add nestjs-prisma --addDocker
</code></pre>

</div>
<p><a href="https://github.com/notiz-dev/nestjs-prisma#additional-options">Check out all options</a> and give it a try with your Nest app.</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dockerizing a NestJS app with Prisma and PostgreSQL]]></title>
        <id>/blog/dockerizing-nestjs-with-prisma-and-postgresql</id>
        <link href="https://notiz.dev/blog/dockerizing-nestjs-with-prisma-and-postgresql"/>
        <updated>2021-11-09T15:00:00.000Z</updated>
        <summary type="html"><![CDATA[How to dockerize a NestJS application with Prisma and PostgreSQL.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.docker.com/">Docker</a> üê≥ enables you to build <strong>consistent</strong> containers of your applications for your development, testing and production environments. In this post you will dockerize a NestJS üò∏ application with Prisma connecting to a PostgreSQL üêò database.</p>
<p>Requirements for this post are</p>
<ol>
<li>Docker <a href="https://docs.docker.com/engine/install/">installed</a></li>
<li><a href="https://notiz.dev/blog/how-to-connect-nestjs-with-prisma">NestJS application with Prisma</a></li>
</ol>
<div shortcode="article" routes="/blog/how-to-connect-nestjs-with-prisma"></div>
<p>You can find the <a href="https://github.com/notiz-dev/nestjs-prisma-docker">full source code</a> on GitHub.</p>
<div shortcode="repo" repo="notiz-dev/nestjs-prisma-docker"></div>
<p>Use this prisma schema to follow along:</p>
<div shortcode="code" tabs="schema.prisma">
<pre><code class="prisma language-prisma">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Food {
  id   Int    @id @default(autoincrement())
  name String
}
</code></pre>

</div>
<p>And a <code>.env</code> file in your <code>prisma</code> directory for a dummy PostgreSQL connection url:</p>
<div shortcode="code" tabs=".env">
<pre><code class="bash language-bash">DATABASE_URL=postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public
</code></pre>

</div>
<h2 id="tldrmultistagedockerfile">TL;DR Multi-stage Dockerfile</h2>
<p>Create a <code>Dockerfile</code> in the root of your Nest application</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">touch Dockerfile
</code></pre>

</div>
<p>Open the <code>Dockerfile</code> and use the multi-stage build steps ü§ô </p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker">FROM node:14 AS builder

# Create app directory
WORKDIR /app

# A wildcard is used to ensure both package.json AND package-lock.json are copied
COPY package*.json ./
COPY prisma ./prisma/

# Install app dependencies
RUN npm install

COPY . .

RUN npm run build

FROM node:14

COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/dist ./dist

EXPOSE 3000
CMD [ "npm", "run", "start:prod" ]
</code></pre>

</div>
<p>But wait‚Ä¶ what is going in the <code>Dockerfile</code> ü§î‚ùì See the breakdown for each step below.</p>
<p>Don't forget to create a <code>.dockerignore</code> file next to your <code>Dockerfile</code>:</p>
<div shortcode="code" tabs=".dockerignore">
<pre><code class="docker language-docker">node_modules
npm-debug.log
</code></pre>

</div>
<p>The <code>COPY</code> command ignores those local files and folder and won't copy them into your Docker image to prevent <strong>overwriting</strong> your installed modules in your image.</p>
<p>Your application structure should look like this:</p>
<div shortcode="figure" caption="Project structure">

![Project structure](assets/img/blog/dockerizing-nestjs-with-prisma-and-postgresql/optimized/project-structure.png)

</div>
<h2 id="breakdownofthemultistagedockerfile">Breakdown of the multi-stage Dockerfile</h2>
<p>Let's breakdown the <code>Dockerfile</code> step-by-step</p>
<p>üèó Builder Image</p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker">FROM node:14 AS builder
</code></pre>

</div>
<p>The first line tells Docker to use the latest <a href="https://nodejs.org/en/about/releases/">LTS</a> version <code>14</code> for <code>node</code> as the base image to build the container from. To optimize the container image size you are using the <a href="https://docs.docker.com/develop/develop-images/multistage-build/">multistage-build</a> and assign a name to your base image <code>AS builder</code>.</p>
<div shortcode="note">

Before updating to a newer version of `node` check the support of Nest, Prisma and other dependencies

</div>
<p>üß∞ Working directory</p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker"># Create app directory
WORKDIR /app
</code></pre>

</div>
<p>Create the working directory for your application which stores your code. All commands (<code>RUN</code>, <code>COPY</code>) are executed inside this directory.</p>
<p>üì¶ Installation</p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker"># A wildcard is used to ensure both package.json AND package-lock.json are copied
COPY package*.json ./
COPY prisma ./prisma/

# Install app dependencies
RUN npm install
</code></pre>

</div>
<p>Next you need to install your app dependencies inside the Docker image. <code>package.json</code> and <code>package-lock.json</code> are copied over. Generating the Prisma Client requires the <code>schema.prisma</code> file. <code>COPY prisma ./prisma/</code> copies the whole <code>prisma</code> directory in case you also need the migrations. </p>
<div shortcode="note">

Only `package*.json` and `prisma` directory is copied in this step to take advantage of the cached Docker layers.

</div>
<p>Install all dependencies <code>RUN npm install</code> (dev too). This allows you to build the Nest application inside the Docker image. Prisma Client is generated directly after, as it defines its own <a href="https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/generating-prisma-client#generating-prisma-client-in-the-postinstall-hook-of-prismaclient">postinstall hook</a>. </p>
<p>‚öôÔ∏è Build app</p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker">COPY . .

RUN npm run build
</code></pre>

</div>
<p>To build your Nest application copy all of your source files (exceptions in <code>.dockerignore</code>) into the Docker image. Now it's time to build your app <code>RUN npm run build</code>.</p>
<p>üëü Run your app</p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker">FROM node:14
</code></pre>

</div>
<p>The second <code>FROM</code> is the second stage in the multi-stage build and is used to <strong>run</strong> your application.   </p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker">COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/dist ./dist
</code></pre>

</div>
<p>Copy <strong>from</strong> your <code>builder</code> image only files and folders required to run the Nest app.</p>
<div shortcode="code" tabs="Dockerfile">
<pre><code class="docker language-docker">EXPOSE 3000
CMD [ "npm", "run", "start:prod" ]
</code></pre>

</div>
<p>Nest apps usually bind to port <code>3000</code>, <code>EXPOSE</code> the same port for your Docker image. Last step is the command to run the Nest application using <code>CMD</code>.</p>
<h2 id="buildandrunyourimage">Build and run your image</h2>
<p>Enter the following command in the directory of your <code>Dockerfile</code>. Give your build image a name using the <code>-t</code> flag to easily start, stop and remove it.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash"># give your docker image a name
docker build -t &lt;your username&gt;/nest-api .

# for example
docker build -t nest-api .
</code></pre>

</div>
<p>After your Docker image is successfully build start it with this command</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">docker run -p 3000:3000 --env-file .env -d &lt;your username&gt;/nest-api 
</code></pre>

</div>
<p>Prisma Client requires the <code>DATABASE_URL</code> environment variable which you pass using the <code>--env-file .env</code> flag. Use this <code>.env</code> file for additional environment variables (Port, JWT Secret etc.) in your root folder.</p>
<p>Open up <a href="http://localhost:3000">localhost:3000</a> to verify that your Nest app is running with Docker.</p>
<h2 id="adddockercomposewithpostgresql">Add docker-compose with PostgreSQL</h2>
<p><a href="https://docs.docker.com/compose/">Docker Compose</a> allows you to define and run multiple Docker container together.
Here you are setting up a Docker compose file for the Nest application and a PostgreSQL database.</p>
<p>Create the Docker compose file</p>
<div shortcode="code" tabs="BASH,docker-compose.yml">
<pre><code class="bash language-bash">touch docker-compose.yml
</code></pre><pre><code class="yaml language-yaml">version: '3.8'
services:
  nest-api:
    container_name: nest-api
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 3000:3000
    depends_on:
      - postgres
    env_file:
      - .env

  postgres:
    image: postgres:13
    container_name: postgres
    restart: always
    ports:
      - 5432:5432
    env_file:
      - .env
    volumes:
      - postgres:/var/lib/postgresql/data

volumes:
  postgres:
    name: nest-db
</code></pre>

</div>
<p>The first service <strong>nest-api</strong> is building the Docker image based on your <code>Dockerfile</code> for your Nest app with Prisma. The second service is creating a <strong>postgres</strong> database using the <code>postgres</code> Docker image in version <code>13</code>. For the Postgres image set <code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code> and <code>POSTGRES_DB</code> environment variables in your root <code>.env</code> file.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">POSTGRES_USER=prisma
POSTGRES_PASSWORD=topsecret
POSTGRES_DB=food
</code></pre>

</div>
<p>To connect to the PostgreSQL database Docker image <a href="https://www.prisma.io/docs/reference/database-connectors/postgresql">configure</a> the <code>DATABASE_URL</code> in your <code>.env</code> file. Fill in your values into the Postgres connection url format</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">postgresql://USER:PASSWORD@HOST:PORT/DB?schema=NAME&amp;sslmode=prefer
</code></pre>

</div>
<p>In this example add the following variable to the <code>.env</code> file. The <code>HOST</code> is when connecting from another Docker image either the service name or the container name - both <code>postgres</code>.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">DATABASE_URL=postgresql://prisma:topsecret@postgres:5432/food?schema=food&amp;sslmode=prefer
</code></pre>

</div>
<p>Time üïô to start your Nest app and Postgres Docker image. Make sure the ports <code>3000</code> and <code>5432</code> are not in use already.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">docker-compose up
# or detached
docker-compose up -d
</code></pre>

</div>
<p>You should have the following two docker containers started</p>
<div shortcode="figure" caption="Docker container started by docker-compose">

![Docker container started by docker-compose](assets/img/blog/dockerizing-nestjs-with-prisma-and-postgresql/optimized/docker-compose.png)

</div>
<p>Open again <a href="http://localhost:3000">localhost:3000</a> to verify that your Nest app is running with Docker. Also verify that your endpoints using the Prisma Client have access to the Postgres DB.</p>
<h2 id="performlocalmigration">Perform local migration</h2>
<p>Replace the host <code>postgres</code> with <code>localhost</code> if you want to perform <a href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-migrate">Prisma migrations</a> locally of your Postgres Docker container. Update the <code>DATABASE_URL</code> in <code>prisma/.env</code> to</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">DATABASE_URL=postgresql://prisma:topsecret@localhost:5432/food?schema=food&amp;sslmode=prefer
</code></pre>

</div>
<p>Now you can run <code>npx prisma migrate dev</code> and seed the database if you like.</p>
<p>Perfect, now sit back and relax üèù and let Docker do the work for you.</p>
<h2 id="performmigrationswithdocker">Perform migrations with Docker</h2>
<p>Checkout how to use <code>prisma migrate deploy</code> in the Dockerfile to perform migrations for your testing, staging and production environment.</p>
<p><div shortcode="article" routes="/blog/prisma-migrate-deploy-with-docker">&lt;/div</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Angular with Tailwind CSS]]></title>
        <id>/blog/angular-with-tailwindcss</id>
        <link href="https://notiz.dev/blog/angular-with-tailwindcss"/>
        <updated>2021-06-03T16:20:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to style Angular applications with Tailwind CSS]]></summary>
        <content type="html"><![CDATA[<p>Learn how to use utility-first CSS framework <a href="https://tailwindcss.com">Tailwind CSS</a> with <a href="https://angular.io/">Angular</a> using <a href="https://github.com/manfredsteyer/ngx-build-plus">ngx-build-plus</a>.</p>
<p>This guide works for both Tailwind CSS v1 and <a href="https://blog.tailwindcss.com/tailwindcss-v2">v2</a> and Angular v10 and <a href="https://blog.angular.io/version-11-of-angular-now-available-74721b7952f7">v11</a>.</p>
<h2 id="angularversion1120orhigher">Angular Version 11.2.0 or higher</h2>
<div shortcode="note" type="warn">
Follow this instructions if your Angular version is 11.2 or higher, otherwise follow [Angular Version below 11.2](https://notiz.dev/blog/angular-with-tailwindcss#angular-version-below-112) instructions.
</div>
<p>Angular added native support for Tailwind CSS with the release of <a href="https://twitter.com/angular/status/1359736376581840896">v11.2</a>. Enable Tailwind CSS with the following 3 steps</p>
<p>üì¶ Install Tailwind dependencies </p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm install -D tailwindcss autoprefixer postcss
</code></pre>

</div>
<p>üèó  Create Tailwind config file via the Tailwind CLI</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npx tailwindcss init
</code></pre>

</div>
<p>Or create <code>tailwind.config.js</code> in your root folder and copy the following content. It already includes purge for your HTML and TS files.</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">module.exports = {
  // mode: 'jit',
  purge: ['./src/**/*.{html,ts}'],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>

</div>
<p>üñåÔ∏è Add Tailwind in your styles file, either <code>src/styles.css</code> or <code>src/styles.scss</code></p>
<div shortcode="code" tabs="src/styles.css,src/styles.scss">
<pre><code class="css language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre><pre><code class="css language-css">@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';
</code></pre>

</div>
<h2 id="angularversionbelow112">Angular Version below 11.2</h2>
<p>You need the <a href="https://cli.angular.io/">Angular CLI</a> to create a new Angular v10 or v11 application.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng new app-name --style=scss
cd app-name
</code></pre>

</div>
<p>Follow the instruction to manually configure Angular w/ Tailwind üç¨üç´üç™ or jump directly to the <a href="https://notiz.dev/blog/angular-10-with-tailwindcss#shortcut-aka-angular-schematics">shortcut</a>.</p>
<h2 id="setup">Setup</h2>
<p>Start by adding dependencies for Tailwind, PostCSS and ngx-build-plus for angular.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm i -D tailwindcss autoprefixer postcss postcss-import postcss-loader postcss-scss

ng add ngx-build-plus
</code></pre>

</div>
<p>Create a <strong>webpack.config.js</strong> in your root folder to configure PostCSS with Tailwind.</p>
<div shortcode="code" tabs="BASH,webpack.config.js">
<pre><code class="bash language-bash">touch webpack.config.js
</code></pre><pre><code class="js language-js">module.exports = {
  module: {
    rules: [
      {
        test: /\.scss$/,
        loader: 'postcss-loader',
        options: {
          postcssOptions: {
            ident: 'postcss',
            syntax: 'postcss-scss',
            plugins: [
              require('postcss-import'),
              require('tailwindcss'),
              require('autoprefixer'),
            ],
          },
        },
      },
    ],
  },
};
</code></pre>

</div>
<p>Now open <strong>angular.json</strong> file to apply the extra webpack config to generate Tailwind styles during <code>ng build</code>, <code>ng serve</code> and <code>ng test</code>. If you used the schematics <code>ng add ngx-build-plus</code> it automatically replaces <code>@angular-devkit/build-angular</code> with <code>ngx-build-plus</code> in your <code>angular.json</code>. Additionally, add the <code>extraWebpackConfig</code> to each build step. In the end your <strong>angular.json</strong> should look like this:</p>
<div shortcode="code" tabs="angular.json">
<pre><code class="diff language-diff">"architect": {
  "build": {
-   "builder": "@angular-devkit/build-angular:browser",
+   "builder": "ngx-build-plus:browser",
    "options": {
+     "extraWebpackConfig": "webpack.config.js",
      ...
    }
    ...
  },
  "serve": {
-   "builder": "@angular-devkit/build-angular:dev-server",
+   "builder": "ngx-build-plus:dev-server",
    "options": {
+     "extraWebpackConfig": "webpack.config.js",
      ...
    }
    ...
  },
  "test": {
-   "builder": "@angular-devkit/build-angular:karma",
+   "builder": "ngx-build-plus:karma",
    "options": {
+     "extraWebpackConfig": "webpack.config.js",
      ...
    }
    ...
  },
</code></pre>

</div>
<p>Perfect, now it's time to generate the Tailwind config <code>npx tailwindcss init</code> or for full config <code>npx tailwindcss init --full</code>. Almost there. Add Tailwind base styles to your <code>src/styles.scss</code> file</p>
<div shortcode="code" tabs="styles.scss">
<pre><code class="css language-css">@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';
</code></pre>

</div>
<p>Now go ahead serve your app, you are ready to style üé® your Angular app with Tailwind utility classes.</p>
<p>‚Ä¶ wait a moment, we need to purge the unused CSS styles from Tailwind.</p>
<h2 id="removeunusedcssstyles">Remove unused CSS Styles</h2>
<p>We can use the new <a href="https://tailwindcss.com/docs/controlling-file-size/#removing-unused-css">purge</a> option in <strong>tailwind.config.js</strong>.</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">module.exports = {
  purge: ['./src/**/*.html', './src/**/*.ts'],
  theme: {
    extend: {},
  },
  variants: {},
  plugins: [],
};
</code></pre>

</div>
<p>Unused styles are removed by Tailwind when you run your build with <code>NODE_ENV</code> set to <code>production</code>. Add <code>"build:prod": "NODE_ENV=production ng build --prod",</code> to your scripts in <strong>package.json</strong>. Now run <code>npm run build:prod</code> for a production build <strong>only</strong> with used Tailwind styles.</p>
<h2 id="cssinsteadofscss">CSS instead of SCSS</h2>
<p>Using CSS instead of SCSS? No problem. You don't need to install <code>postcss-scss</code>.</p>
<div shortcode="code" tabs="BASH,webpack.config.js">
<pre><code class="bash language-bash">npm i -D tailwindcss autoprefixer postcss postcss-import postcss-loader 

ng add ngx-build-plus
</code></pre><pre><code class="js language-js">module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        loader: 'postcss-loader',
        options: {
          postcssOptions: {
            ident: 'postcss',
            syntax: 'postcss',
            plugins: [
              require('postcss-import'),
              require('tailwindcss'),
              require('autoprefixer'),
            ],
          },
        },
      },
    ],
  },
};
</code></pre>

</div>
<p>Finally add Tailwind base styles to <code>src/styles.css</code>.</p>
<div shortcode="code" tabs="styles.css">
<pre><code class="css language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>

</div>
<h2 id="shortcutakaangularschematics">Shortcut aka Angular Schematics</h2>
<p>If you also think the steps above are tedious ‚Ä¶ Don't look any further.</p>
<p>Angular Schematics üí™ to the rescue. <a href="https://notiz.dev/authors/gary-grossgarten">Gary</a> created a schematic to add Tailwind to an Angular project.</p>
<div shortcode="repo" repo="notiz-dev/ngx-tailwind"></div>
<p>Simply run the schematic to automatically configure Tailwind CSS:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng add ngx-tailwind
</code></pre>

</div>
<h2 id="usetailwindcssutilityclasses">Use Tailwind CSS utility classes</h2>
<p>Now go crazy with Tailwind's CSS utility classes in your Angular app.</p>
<p>Add them to your HTML template <code>class</code>, <code>[class.hover:...]="true"</code> or use them with <code>ngClass</code></p>
<div shortcode="code" tabs="HTML,CSS">
<pre><code class="html language-html">&lt;span class="inline-block bg-red-500 rounded-full px-3 py-1 text-sm font-semibold text-white" [class.hover:bg-red-700]="hoverMe"&gt;
  #angular
&lt;/span&gt;
</code></pre><pre><code class="css language-css">span {
  @apply inline-block bg-red-500 rounded-full px-3 py-1 text-sm font-semibold text-white;
} 

span:hover {
  @apply bg-red-700;
} 
</code></pre>

</div>
<div shortcode="note">
@apply is not compiled when using it in an Angular library due to [missing support for postcss](https://github.com/ng-packagr/ng-packagr/issues/1471) of ng-packagr.
</div>
<p>Or use <code>@HostBinding</code> in your <code>*.ts</code> files</p>
<div shortcode="code" tabs="TS">
<pre><code class="ts language-ts">@HostBinding('class')
get classes() {
  return 'bg-red-500 px-4';
}

@HostBinding('class.hidden')
get classes() {
  return this.isHidden;
}
</code></pre>

</div>
<p>Add the following snippet to your <code>src/app.component.html</code> to see if Tailwind styles the following card. (Don't worry about the picture its random)</p>
<div shortcode="figure" caption="Angular Tailwind Card">

![Angular Tailwind Card](assets/img/blog/angular-10-with-tailwindcss/optimized/angular-tailwind-card.png)

</div>
<div shortcode="code" tabs="HTML">
<pre><code class="html language-html">&lt;div class="max-w-sm mx-auto mt-8 rounded overflow-hidden shadow-lg space-y-4"&gt;
  &lt;img
    class="h-64 w-full object-cover object-center"
    src="https://source.unsplash.com/random"
    alt="Random unsplash photo"
  /&gt;
  &lt;div class="px-6"&gt;
    &lt;div class="font-bold text-xl"&gt;Angular w/ Tailwind&lt;/div&gt;
    &lt;p class="text-gray-700 text-base"&gt;
      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptatibus
      quia, nulla! Maiores et perferendis eaque, exercitationem praesentium
      nihil.
    &lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="px-6 pb-4 space-x-2"&gt;
    &lt;a
      href="https://angular.io"
      target="_blank"
      rel="noreferrer"
      class="inline-block bg-red-500 rounded-full px-3 py-1 text-sm font-semibold text-white hover:bg-red-700"
    &gt;
      #angular
    &lt;/a&gt;
    &lt;a
      href="https://tailwindcss.com"
      target="_blank"
      rel="noreferrer"
      class="inline-block bg-indigo-500 rounded-full px-3 py-1 text-sm font-semibold text-white hover:bg-indigo-700"
    &gt;
      #tailwind
    &lt;/a&gt;
    &lt;a
      href="https://notiz.dev"
      target="_blank"
      rel="noreferrer"
      class="inline-block bg-blue-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 hover:bg-blue-400"
    &gt;
      #notiz
    &lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

</div>
<p>In the next post you will create an Angular component for a floating form field based on my last post <a href="https://notiz.dev/blog/floating-form-field-with-tailwindcss">Floating Form Field with Tailwind CSS</a>.</p>
<h2 id="migrations">Migrations</h2>
<h3 id="upgradingfromtailwindcssv1tov2">Upgrading from Tailwind CSS v1 to v2</h3>
<p>To upgrade you project from <a href="https://tailwindcss.com/docs/upgrading-to-v2">Tailwind CSS v1.x to v2.0</a> run the following install command</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm i -D tailwindcss@latest postcss@latest autoprefixer@latest postcss-import@latest
</code></pre>

</div>
<p>Read the full <a href="https://tailwindcss.com/docs/upgrading-to-v2">Upgrade Guide</a> to update your custom <code>tailwind.config.js</code> (e.g. <a href="https://tailwindcss.com/docs/upgrading-to-v2#configure-your-color-palette-explicitly">your color palette</a>) and replace removed classes from your template (e.g. <a href="https://tailwindcss.com/docs/upgrading-to-v2#replace-shadow-outline-and-shadow-xs-with-ring-utilities">shadow-outline and shadow-xs</a>).</p>
<h3 id="updatepostcssloaderfrom3xto4x">Update postcss-loader from 3.x to 4.x</h3>
<p><a href="https://github.com/webpack-contrib/postcss-loader">postcss-loader</a> has new <a href="https://github.com/webpack-contrib/postcss-loader/blob/master/CHANGELOG.md#-breaking-changes">breaking changes</a> when updating from version 3.x to 4.x. Huge thanks to <a href="https://github.com/notiz-dev/notiz/issues/111#issuecomment-689249664">@phileagleson</a> :clap: who pointed out that options for PostCSS have moved to the <code>postcssOptions</code>. Therefore, update your <code>webpack.config.js</code> as follows when updating to <code>postcss-loader@4.x</code></p>
<div shortcode="code" tabs="webpack.config.js">
<pre><code class="diff language-diff">module.exports = {
  module: {
    rules: [
      {
        test: /\.scss$/,
        loader: 'postcss-loader',
        options: {
-          ident: 'postcss',
-          syntax: 'postcss-scss',
-          plugins: () =&gt; [
-            require('postcss-import'),
-            require('tailwindcss'),
-            require('autoprefixer'),
-          ],
+          postcssOptions: {
+           ident: 'postcss',
+            syntax: 'postcss-scss',
+            plugins: [
+              require('postcss-import'),
+              require('tailwindcss'),
+              require('autoprefixer'),
            ],
          },
        },
      },
    ],
  },
};
</code></pre>

</div>
<p>All <code>webpack.config.js</code> examples are updated to use the new <code>postcssOptions</code> for <code>postcss-loader@4.x</code>.</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Create Keyboard Shortcuts with RxJS]]></title>
        <id>/blog/simple-rxjs-keyboard-shortcuts</id>
        <link href="https://notiz.dev/blog/simple-rxjs-keyboard-shortcuts"/>
        <updated>2020-06-08T19:20:51.808Z</updated>
        <summary type="html"><![CDATA[The cleanest way to create and orchestrate Keyboard Shortcuts with RxJS.]]></summary>
        <content type="html"><![CDATA[<p>I recently tried to add some keyboard shortcuts to my Angular app. ü§Ø <strong>But don't worry</strong>, the solution is quite simple. At least Brent Rambo approves.</p>
<p align="center">
<img width="80%" max-width="640px" src="https://media.giphy.com/media/m2Q7FEc0bEr4I/source.gif" alt="Brent Rambo - Shortcut master">
</p>
<p>In this <a href="https://notiz.dev/tags/quick-tip">Quick Tip</a>, I'll show you what I came up with, using <a href="https://rxjs-dev.firebaseapp.com/">RxJS</a>.
This demonstration is done in an Angular Workspace scaffolded with the <a href="https://cli.angular.io/">Angular CLI</a>.</p>
<h2 id="implementation">Implementation</h2>
<p>The <code>shortcut</code> function below can be used to effortlessly create <code>Observables</code> for any keyboard shortcut. A keyboard shortcut is an array of keycodes (<code>event.code</code>), each representing a key of your keyboard. Grab the <a href="https://github.com/garygrossgarten/rxjs-shortcuts/blob/master/projects/shortcuts/src/lib/keycodes.ts">KeyCode Enum here</a>.</p>
<p>See the comments in the code for explanation:</p>
<div shortcode="code" tabs="TS">
<pre><code class="ts language-ts">export const shortcut = (shortcut: KeyCode[]): Observable&lt;KeyboardEvent[]&gt; =&gt; {
  // Observables for all keydown and keyup events
  const keyDown$ = fromEvent&lt;KeyboardEvent&gt;(document, 'keydown');
  const keyUp$ = fromEvent&lt;KeyboardEvent&gt;(document, 'keyup');

  // All KeyboardEvents - emitted only when KeyboardEvent changes (key or type)
  const keyEvents$ = merge(keyDown$, keyUp$).pipe(
    distinctUntilChanged((a, b) =&gt; a.code === b.code &amp;&amp; a.type === b.type),
    share()
  );

  // Create KeyboardEvent Observable for specified KeyCode
  const createKeyPressStream = (charCode: KeyCode) =&gt;
    keyEvents$.pipe(filter((event) =&gt; event.code === charCode.valueOf()));

  // Create Event Stream for every KeyCode in shortcut
  const keyCodeEvents$ = shortcut.map((s) =&gt; createKeyPressStream(s));

  // Emit when specified keys are pressed (keydown).
  // Emit only when all specified keys are pressed at the same time.
  // More on combineLatest below
  return combineLatest(keyCodeEvents$).pipe(
    filter&lt;KeyboardEvent[]&gt;((arr) =&gt; arr.every((a) =&gt; a.type === 'keydown'))
  );
};
</code></pre>

</div>
<div shortcode="note">
**[combineLatest](https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest)**: Whenever any input `Observable` emits, `combineLatest` will compute and emit all the latest values of all inputs. However, `combineLatest` will wait for all input `Observables` to emit at least once, before it starts emitting results.
</div>
<h2 id="usage">Usage</h2>
<p><strong>Usage is simple</strong>. Just call the <code>shortcut</code> function with your desired <code>KeyCode</code> combination. Then subscribe to the result and handle the keyboard shortcut. More examples can be found in the <a href="https://github.com/garygrossgarten/rxjs-shortcuts">repo</a>.</p>
<div shortcode="code" tabs="TS">
<pre><code class="ts language-ts">const commaDot$ = shortcut([KeyCode.Comma, KeyCode.Period]);

const ctrlO$ = merge(
  shortcut([KeyCode.ControlLeft, KeyCode.KeyO]),
  shortcut([KeyCode.ControlRight, KeyCode.KeyO])
);

commaDot$.pipe(tap(() =&gt; doSomething())).subscribe();
</code></pre>

</div>
<h2 id="bonus">Bonus</h2>
<p>The <code>shortcut</code> function emits whenever the specified keys are pressed simultaneously, no matter in which order they were pressed. If the sequence of the key presses is also important to you, you can use the pipeable operator below.</p>
<div shortcode="code" tabs="TS">
<pre><code class="ts language-ts">export function sequence() {
  return (source: Observable&lt;KeyboardEvent[]&gt;) =&gt; {
    return source.pipe(
      filter((arr) =&gt; {
        const sorted = [...arr]
          .sort((a, b) =&gt; (a.timeStamp &lt; b.timeStamp ? -1 : 1))
          .map((a) =&gt; a.code)
          .join();
        const seq = arr.map((a) =&gt; a.code).join();
        return sorted === seq;
      })
    );
  };
}
</code></pre>

</div>
<p>Then use it like this</p>
<div shortcode="code" tabs="TS">
<pre><code class="typescript language-typescript">const abc$ = shortcut([KeyCode.KeyA, KeyCode.KeyB, KeyCode.KeyC]).pipe(
  sequence()
);
</code></pre>

</div>
<p>Now the <code>abc$</code> <code>Observable</code> will only emit when the keys are pressed sequentially (a-&gt;b-&gt;c).</p>
<h2 id="limitations">Limitations</h2>
<p>Beware that keyboard shortcuts could collide with global shortcuts specified by your OS or Browser (e.g. Spotlight on Mac for Cmd+Space). Also there are cases where <code>keyup</code> events will be skipped when certain keys are pressed down. This is particularly the case with the cmd key (<code>KeyCode.MetaRight</code> and <code>KeyCode.MetaLeft</code>) on mac.</p>
<hr />
<p>If you have further questions on the article or just want to say hi, feel free to slide into my <a href="https://twitter.com/garygrossgarten">twitter dms</a>.üê¶</p>]]></content>
        <author>
            <name>Gary Gro√ügarten</name>
        </author>
        <contributor>
            <name>gary-gro√ügarten</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Floating Form Field with Tailwind CSS]]></title>
        <id>/blog/floating-form-field-with-tailwindcss</id>
        <link href="https://notiz.dev/blog/floating-form-field-with-tailwindcss"/>
        <updated>2020-05-28T21:50:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to build a floating form field with Tailwind CSS]]></summary>
        <content type="html"><![CDATA[<p>In the following lesson you will learn how to use <a href="https://tailwindcss.com">Tailwind CSS</a> utility-first approach to create a floating form field known from <a href="https://material.io/components/text-fields">Material Design</a>. This is inspired by the awesome video from <a href="https://www.youtube.com/watch?v=yrrw6KdGuxc">fireship.io</a>.</p>
<div shortcode="figure" caption="Floating Form">

![Floating Form](assets/img/blog/floating-form-field-with-tailwindcss/floating-form.gif)

</div>
<p>You can follow along in a new project or get the <a href="https://github.com/notiz-dev/floating-form-field-tailwindcss">source code</a> from GitHub.</p>
<h2 id="setup">Setup</h2>
<p>Let's start in an empty directory and setup up a default <code>package.json</code> file using <code>npm init -y</code>.</p>
<h3 id="setuptailwindcss">Setup Tailwind CSS</h3>
<p>Setup <a href="https://tailwindcss.com/docs/installation/">Tailwind</a> by installing</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm i -D tailwindcss postcss-cli autoprefixer
</code></pre>

</div>
<p>Generate a Tailwind config file as you will <a href="https://tailwindcss.com/docs/configuration/">customize</a> Tailwind for the floating form field later.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npx tailwindcss init
</code></pre>

</div>
<p>Create <code>postcss.config.js</code> file requiring <code>tailwindcss</code> and <code>autoprefixer</code> as a plugin:</p>
<div shortcode="code" tabs="postcss.config.js">
<pre><code class="js language-js">module.exports = {
  plugins: [
    require("tailwindcss"),
    require("autoprefixer")
  ]
};
</code></pre>

</div>
<p>Create your tailwind styles under <code>css/tailwind.css</code></p>
<div shortcode="code" tabs="tailwind.css">
<pre><code class="css language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>

</div>
<p>Add those scripts to your <code>package.json</code> one to build and the other to watch changes made to the <code>tailwind.css</code> file.</p>
<div shortcode="code" tabs="package.json">
<pre><code class="json language-json">"scripts": {
  "build": "postcss css/tailwind.css -o public/build/tailwind.css",
  "dev": "postcss css/tailwind.css -o public/build/tailwind.css -w"
},
</code></pre>

</div>
<h3 id="setuphtml">Setup HTML</h3>
<p>Start with the following simple HTML layout - create an <code>index.html</code> in the <strong>public</strong> directory.</p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;FFFwT&lt;/title&gt;

    &lt;link rel="stylesheet" href="build/tailwind.css" /&gt;
  &lt;/head&gt;
  &lt;body class="antialiased p-10"&gt;
    &lt;form&gt;
      &lt;div&gt;
        &lt;input type="text" name="username" placeholder=" " /&gt;
        &lt;label for="username"&gt;Username&lt;/label&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

</div>
<p>You can use <a href="https://www.npmjs.com/package/live-server">live-server</a> to start a dev-server with live reload.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">live-server public
</code></pre>

</div>
<p>Here you have your starting point - an input and a label.</p>
<div shortcode="figure" caption="Input and Label">

![Input and Label](assets/img/blog/floating-form-field-with-tailwindcss/optimized/1-input-and-label.png)

</div>
<p>Let's add styles to create a floating form field.</p>
<h2 id="floatingformfield">Floating Form Field</h2>
<h3 id="focusborder">Focus Border</h3>
<p>Start by adding a bottom border to the <code>div</code> using <code>border-b-{width}</code></p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html">&lt;div class="border-b-2"&gt;
  &lt;input type="text" name="username" placeholder=" " /&gt;
  &lt;label for="username"&gt;Username&lt;/label&gt;
&lt;/div&gt;
</code></pre>

</div>
<div shortcode="figure" caption="Border bottom">

![Border bottom](assets/img/blog/floating-form-field-with-tailwindcss/optimized/2-border.png)

</div>
<p>To change the border color when the input is focused use the pseudo-class <code>focus-within</code>. Enable the <a href="https://tailwindcss.com/docs/pseudo-class-variants/#focus-within">focus-within variant</a> in Tailwind for <code>borderColor</code> by adding it in the <code>tailwind.config.js</code> under the variants section:</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">variants: {
  borderColor: ['responsive', 'hover', 'focus', 'focus-within'],
},
</code></pre>

</div>
<p>Now add <code>focus-within:border-blue-500</code> to change the border color on focus</p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html">&lt;div class="my-4 border-b-2 focus-within:border-blue-500"&gt;
  &lt;input type="text" name="username" placeholder=" " /&gt;
  &lt;label for="username"&gt;Username&lt;/label&gt;
&lt;/div&gt;
</code></pre>

</div>
<div shortcode="figure" caption="Change border color on focus">

![Change border color on focus](assets/img/blog/floating-form-field-with-tailwindcss/optimized/3-focus-border-color.png)

</div>
<h3 id="floatinglabel">Floating Label</h3>
<p>Begin with changing the position of the <code>div</code> to <code>relative</code> so that you can use <code>top</code> to control the position of the <code>label</code>. Add <code>class="absolute top-0"</code> to the <code>label</code>.</p>
<p><code>input</code> is an inline element, add the Tailwind <code>block</code> class to change it to a block element. Also set the input width to 100% with <code>w-full</code> to tap the input on the whole form field. Additionally, add <code>appearance-none</code> and <code>focus:outline-none</code> to the input to remove browser specific styles.</p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html">&lt;div class="relative my-4 border-b-2 focus-within:border-blue-500"&gt;
  &lt;input type="text" name="username" placeholder=" " class="block w-full appearance-none focus:outline-none" /&gt;
  &lt;label for="username" class="absolute top-0"&gt;Username&lt;/label&gt;
&lt;/div&gt;
</code></pre>

</div>
<p>Currently the label is covering the input field and preventing you from focusing the input üôà.</p>
<div shortcode="figure" caption="Label is covering up the input">

![Label is covering up the input](assets/img/blog/floating-form-field-with-tailwindcss/optimized/4-label-covers-input.png)

</div>
<p>Let's change the <code>z-index</code> of the label to be behind the input field by setting it to <code>z-index: -1</code>. Extend the Tailwind theme to generate a negative z-index for you:</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">theme: {
  extend: {
    zIndex: {
      "-1": "-1",
    },
  },
}
</code></pre>

</div>
<p>Add <code>-z-1</code> class to the label, now the label is not visible anymore. Add <code>bg-transparent</code> to the <code>input</code>. </p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html">&lt;div class="relative my-4 border-b-2 focus-within:border-blue-500"&gt;
  &lt;input type="text" name="username" placeholder=" " class="block w-full appearance-none focus:outline-none bg-transparent" /&gt;
  &lt;label for="username" class="absolute top-0 -z-1"&gt;Username&lt;/label&gt;
&lt;/div&gt;
</code></pre>

</div>
<p>The label is visible again and the input field can be focused by taping on the label too üêµ.</p>
<p>Next make the label float above the input, again, using the pseudo-class <code>focus-within</code>. Open your <code>tailwind.css</code> and add the following CSS selector:</p>
<div shortcode="code" tabs="tailwind.css">
<pre><code class="css language-css">input:focus-within ~ label {

}
</code></pre>

</div>
<p>Now use Tailwind's <a href="https://tailwindcss.com/docs/functions-and-directives/#apply">@apply</a> to transform, scale and change the label text color on input focus.</p>
<div shortcode="code" tabs="tailwind.css">
<pre><code class="css language-css">input:focus-within ~ label {
 @apply transform scale-75 -translate-y-6 text-blue-500;
}
</code></pre>

</div>
<p>Also add <code>duration-300</code> to your label class to control the labels transition duration.</p>
<div shortcode="figure" caption="Floating label on focus">

![Floating label on focus](assets/img/blog/floating-form-field-with-tailwindcss/optimized/5-floating-label-on-focus.png)

</div>
<p>Awesome the label is floating üéà, however, it stops floating when you remove the focus from the input üòû. The label should float if the input field has some content. Target the <code>placeholder</code>, if its not shown <code>input:not(:placeholder-shown) ~ label</code> thus the input has content and the label should float. </p>
<div shortcode="code" tabs="tailwind.css">
<pre><code class="css language-css">input:focus-within ~ label,
input:not(:placeholder-shown) ~ label {
  @apply transform scale-75 -translate-y-6;
}

input:focus-within ~ label {
  @apply text-blue-500;
}
</code></pre>

</div>
<div shortcode="figure" caption="Floating label without focus">

![Floating label without focus](assets/img/blog/floating-form-field-with-tailwindcss/optimized/6-floating-label-without-focus.png)

</div>
<p>Yeah ü§©, the label floats on focus and if the input has content. It seems the label is not aligned with the input field. Set <code>transform-origin</code> on the label to 0%. Let Tailwind generate it for you, open <code>tailwind.config.js</code> and add it to the theme section:</p>
<div shortcode="code" tabs="tailwind.config.js">
<pre><code class="js language-js">theme: {
  extend: {
    transformOrigin: {
      "0": "0%",
    },
    zIndex: {
      "-1": "-1",
    },
  },
}
</code></pre>

</div>
<p>Now add <code>origin-0</code> to the label and finally you have your own floating form field made with Tailwind CSS üòçüöÄ</p>
<div shortcode="figure" caption="Floating label without focus">

![Floating Form Field](assets/img/blog/floating-form-field-with-tailwindcss/optimized/7-floating-form-field.png)

</div>
<h3 id="buildingaform">Building a form</h3>
<p>Let's build a form field by duplicating the floating form field or by extracting the styles with <a href="https://tailwindcss.com/docs/functions-and-directives/#apply">@apply</a>.</p>
<p>Add <code>space-y-{size}</code> to the form to add margin between your input fields. You could also wrap it with a card.</p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html"> &lt;form class="max-w-sm mx-auto rounded-lg shadow-xl overflow-hidden p-6 space-y-10"&gt;
  &lt;h2 class="text-2xl font-bold text-center"&gt;Login&lt;/h2&gt;
  &lt;div class="relative border-b-2 focus-within:border-blue-500"&gt;
    &lt;input type="text" name="username" placeholder=" " class="block w-full appearance-none focus:outline-none bg-transparent" /&gt;
    &lt;label for="username" class="absolute top-0 -z-1 duration-300 origin-0"&gt;Username&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="relative border-b-2 focus-within:border-blue-500"&gt;
    &lt;input type="text" name="email" placeholder=" " class="block w-full appearance-none focus:outline-none bg-transparent" /&gt;
    &lt;label for="email" class="absolute top-0 -z-1 duration-300 origin-0"&gt;Email&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="relative border-b-2 focus-within:border-blue-500"&gt;
    &lt;input type="password" name="password" placeholder=" " class="block w-full appearance-none focus:outline-none bg-transparent" /&gt;
    &lt;label for="password" class="absolute top-0 -z-1 duration-300 origin-0"&gt;Password&lt;/label&gt;
  &lt;/div&gt;
&lt;/form&gt;
</code></pre>

</div>
<p>Here you have your first form using the floating form field</p>
<div shortcode="figure" caption="Floating label without focus">

![Floating form](assets/img/blog/floating-form-field-with-tailwindcss/floating-form.gif)

</div>
<p>Next, try out another style - Outline Form Field.</p>
<h2 id="outlineformfield">Outline Form Field</h2>
<p>In this style the form field has an outline all around and the label floats into the outline. Reuse the floating form field and change <code>border-b-2</code> to <code>border-2</code> this gives you the outline. </p>
<p>Add padding <code>p-4</code> to create space inside the outline and increase the font size <code>text-lg</code> of the input and the label.</p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html">&lt;div class="relative border-2 focus-within:border-blue-500"&gt;
  &lt;input type="text" name="username" placeholder=" " class="block p-4 w-full text-lg appearance-none focus:outline-none bg-transparent" /&gt;
  &lt;label for="username" class="absolute top-0 p-4 text-lg -z-1 duration-300 origin-0"&gt;Username&lt;/label&gt;
&lt;/div&gt;
</code></pre>

</div>
<p>Look at our outline form field</p>
<div shortcode="figure" caption="Outline form field">

![Outline form field](assets/img/blog/floating-form-field-with-tailwindcss/optimized/8-outline-form-field.png)

</div>
<p>Focus the input and you notice the label is <strong>not</strong> covering up the outline.</p>
<div shortcode="figure" caption="Floating label not covering the outline">

![Floating label not covering the outline](assets/img/blog/floating-form-field-with-tailwindcss/optimized/9-outline-floating-label-below.png)

</div>
<p>To make the label cover up the outline customize the floating CSS applied to the outline form field. Duplicate the custom CSS in your <code>tailwind.css</code> and add <code>.outline</code> class to both selectors. Add <code>outline</code> class to the <code>div</code> around your input and label.</p>
<div shortcode="code" tabs="tailwind.css">
<pre><code class="css language-css">.outline input:focus-within ~ label,
.outline input:not(:placeholder-shown) ~ label {
  @apply transform scale-75 -translate-y-6;
}
</code></pre>

</div>
<p>Update a few styles on the label to remove the top and bottom padding - <code>py-0</code>. Also reduce the left and right padding to <code>px-1</code>, add margin left <code>ml-3</code> to align it with the input. Reset the z-index to <code>z-0</code> that the label is above the outline. Finally, reduce the translate y value until the label is perfectly matching the outline.</p>
<div shortcode="code" tabs="tailwind.css">
<pre><code class="css language-css">.outline input:focus-within ~ label,
.outline input:not(:placeholder-shown) ~ label {
  @apply transform scale-75 -translate-y-4 z-0 ml-3 px-1 py-0;
}
</code></pre>

</div>
<p>Perfect the label is exactly on the outline, but the line is still visible.</p>
<div shortcode="figure" caption="Floating label not covering the outline">

![Floating label covers outline with line through](assets/img/blog/floating-form-field-with-tailwindcss/optimized/10-outline-floating-label-with-line-through.png)

</div>
<p>To hide the outline set the background of the label to the same background of the container where you place the form field. Add <code>bg-white</code> to the label, this should do the trick.</p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html">&lt;div class="outline relative border-2 focus-within:border-blue-500"&gt;
  &lt;input type="text" name="username" placeholder=" " class="block p-4 w-full text-lg appearance-none focus:outline-none bg-transparent" /&gt;
  &lt;label for="username" class="absolute top-0 text-lg bg-white p-4 -z-1 duration-300 origin-0"&gt;Username&lt;/label&gt;
&lt;/div&gt;
</code></pre>

</div>
<p>Now you have the outline form field working too. üëç</p>
<h3 id="buildingaform-1">Building a form</h3>
<p>Now create a form using the outline style.</p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html">&lt;form class="max-w-sm mx-auto rounded-lg shadow-xl overflow-hidden p-6 space-y-10"&gt;
  &lt;h2 class="text-2xl font-bold text-center"&gt;Login&lt;/h2&gt;
  &lt;div class="outline relative border-2 focus-within:border-blue-500"&gt;
    &lt;input type="text" name="username" placeholder=" " class="block p-4 w-full text-lg appearance-none focus:outline-none bg-transparent" /&gt;
    &lt;label for="username" class="absolute top-0 text-lg bg-white p-4 -z-1 duration-300 origin-0"&gt;Username&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="outline relative border-2 focus-within:border-blue-500"&gt;
    &lt;input type="email" name="email" placeholder=" " class="block p-4 w-full text-lg appearance-none focus:outline-none bg-transparent" /&gt;
    &lt;label for="email" class="absolute top-0 text-lg bg-white p-4 -z-1 duration-300 origin-0"&gt;Email&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="outline relative border-2 focus-within:border-blue-500"&gt;
    &lt;input type="password" name="password" placeholder=" " class="block p-4 w-full text-lg appearance-none focus:outline-none bg-transparent" /&gt;
    &lt;label for="password" class="absolute top-0 text-lg bg-white p-4 -z-1 duration-300 origin-0"&gt;Password&lt;/label&gt;
  &lt;/div&gt;
&lt;/form&gt;
</code></pre>

</div>
<div shortcode="figure" caption="Outline Form">

![Outline Form](assets/img/blog/floating-form-field-with-tailwindcss/outline-form.gif)

</div>
<p>If you followed along, create and customize your own floating form field w/ Tailwind CSS. Send me your own design on Twitter <a href="https://twitter.com/mrcjln">@mrcjln</a>.</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Migrate Git Repository to Git Large File Storage (LFS)]]></title>
        <id>/blog/migrate-git-repo-to-git-lfs</id>
        <link href="https://notiz.dev/blog/migrate-git-repo-to-git-lfs"/>
        <updated>2020-04-26T15:45:00.000Z</updated>
        <summary type="html"><![CDATA[How to migrate an existing Git Repository to use Git Large File Storage (LFS).]]></summary>
        <content type="html"><![CDATA[<p>If you ever come across this error while pushing an existing repository or a large file to GitHub‚Ä¶</p>
<p><code>remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.</code></p>
<p>‚Ä¶ here is how to setup <a href="https://git-lfs.github.com/">Git Large File Storage (LFS)</a> and migrate your Git history.</p>
<h2 id="1downloadandinstallgitlfsextension">1. Download and Install Git LFS extension</h2>
<p>Download and install the <a href="https://git-lfs.github.com/">Git LFS</a> extension, you can also install it using <a href="https://brew.sh/">Homebrew</a>.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">brew install git-lfs
</code></pre>

</div>
<h2 id="2setupgitlfsforyourcurrentuseraccount">2. Setup Git LFS for your current user account</h2>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">git lfs install
</code></pre>

</div>
<h2 id="3selectfilestobemanagedbygitlfs">3. Select files to be managed by Git LFS</h2>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash"># track files by file type
git lfs track "*.zip"

# track directories by path
git lfs track "assets/*"

# track entire directory trees
git lfs track "assets/**/*"

# track file by path
git lfs track "path/to/file"
</code></pre>

</div>
<p><code>git lfs track</code> will add the files tracked by Git LFS to <code>.gitattributes</code>. It is important to add <code>.gitattributes</code> to Git.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">git add .gitattributes
</code></pre>
</div>
<div shortcode="note" type="warn">
Tracking files are **not** automatically converting these files from your Git history or other branches.
</div>
<h2 id="4migrategithistory">4. Migrate Git History</h2>
<p>If you have existing files in your Git history or in other branches you need to migrate those files to be tracked by Git LFS as well. Git LFS provides a command <a href="https://github.com/git-lfs/git-lfs/blob/master/docs/man/git-lfs-migrate.1.ronn?utm_source=gitlfs_site&utm_medium=doc_man_migrate_link&utm_campaign=gitlfs">git lfs migrate</a> with various options depending on your use case.</p>
<p>Before performing your migration you can perform a dry run with <code>git lfs migrate info [options]</code>. Use the option <code>--everything</code> to perform a migration in every branch. If you only want to migrate files you added before with <code>git lfs track</code> you will add those with the <code>--include="*.zip,src/assets"</code> flag comma separated.</p>
<p>Here is an example which performs a migration for all Zip-files.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash"># dry run of your migration
git lfs migrate info --everything --include="*.zip"

# perform migration
git lfs migrate import --everything --include="*.zip" --verbose
</code></pre>

</div>
<p>Now go ahead and push your repository to GitHub. If successfully pushed and setup GitHub displays the following tag for each file tracked by Git LFS.</p>
<div shortcode="figure" caption="Stored with Git LFS on GitHub">

![Stored with Git LFS on GitHub](assets/img/blog/migrate-git-repo-to-git-lfs/optimized/stored-with-git-lfs.png)

</div>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to manage multiple Java JDK versions on macOS X]]></title>
        <id>/blog/how-to-manage-multiple-java-versions-on-mac</id>
        <link href="https://notiz.dev/blog/how-to-manage-multiple-java-versions-on-mac"/>
        <updated>2020-10-23T12:08:00.000Z</updated>
        <summary type="html"><![CDATA[How to manage multiple Java JDK versions on macOS X using homebrew.]]></summary>
        <content type="html"><![CDATA[<p>Here is a quick tip on how to install multiple <a href="https://www.oracle.com/java/technologies/javase-downloads.html#javasejdk">Java JDK</a> versions (8, ‚Ä¶, 11, ‚Ä¶, 14 etc.) on macOS X and how to switch between them for your applications.</p>
<h2 id="installingjavajdkviahomebrew">Installing Java JDK via Homebrew</h2>
<p>Install multiple Java JDK versions using <a href="https://brew.sh/">Homebrew</a>. To install Homebrew run:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
</code></pre>

</div>
<p>Now install the Java JDK version <strong>11</strong> or above using <code>brew cask</code>:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">brew cask install java&lt;version&gt;

# latest version
brew cask install java
</code></pre>

</div>
<div shortcode="note">
JDK versions  **8**, **9**, **10** and **11** are no longer supported.
</div>
<p><a href="https://adoptopenjdk.net/">AdoptOpenJDK</a> provides older Java versions. To install the Java JDKs from AdoptOpenJDK:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash"># install from third party repository
brew tap adoptopenjdk/openjdk

brew cask install adoptopenjdk&lt;version&gt;

# Java 8
brew cask install adoptopenjdk8

# Java 9
brew cask install adoptopenjdk9

# Java 10
brew cask install adoptopenjdk10

# Java 11
brew cask install adoptopenjdk11
</code></pre>

</div>
<h2 id="switchjavajdkviaalias">Switch Java JDK via alias</h2>
<p>Setup your <code>JAVA_HOME</code> path in your <code>.zshrc</code> or <code>.bash_profile</code> for your primary Java version and add an export for each installed Java version.</p>
<div shortcode="code" tabs=".zshrc/.bash_profile">
<pre><code class="bash language-bash">export JAVA_HOME=$(/usr/libexec/java_home -v14)

export JAVA_8_HOME=$(/usr/libexec/java_home -v1.8)
export JAVA_11_HOME=$(/usr/libexec/java_home -v11)
export JAVA_14_HOME=$(/usr/libexec/java_home -v14)
</code></pre>

</div>
<p>To check the default Java version and installation path:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">java -version # 14
</code></pre>

</div>
<p>Add an alias to your <code>.zshrc</code> or <code>.bash_profile</code> for each installed Java version. The alias exports <code>JAVA_HOME</code> with the selected <code>JAVA_VERSION_HOME</code>.</p>
<div shortcode="code" tabs=".zshrc/.bash_profile">
<pre><code class="bash language-bash">alias java8='export JAVA_HOME=$JAVA_8_HOME'
alias java11='export JAVA_HOME=$JAVA_11_HOME'
alias java14='export JAVA_HOME=$JAVA_14_HOME'
</code></pre>

</div>
<p>Now, to switch between the Java versions, enter an alias <code>java8</code> in your terminal. Execute <code>java -version</code> to verify that you are now using the correct Java version.</p>
<div shortcode="note">
Alias **only** changes the Java version in the used terminal instance
</div>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraphQL Code-First Approach with NestJS 7]]></title>
        <id>/blog/graphql-code-first-with-nestjs-7</id>
        <link href="https://notiz.dev/blog/graphql-code-first-with-nestjs-7"/>
        <updated>2020-04-07T11:56:00.000Z</updated>
        <summary type="html"><![CDATA[Create a GraphQL API using Code-First Approach with NestJS 7.]]></summary>
        <content type="html"><![CDATA[<p>Recently the release of <a href="https://trilon.io/blog/announcing-nestjs-7-whats-new">NestJS 7</a> was announced with amazing updates to the whole framework including the <a href="https://docs.nestjs.com/graphql/quick-start">@nestjs/graphql</a> ‚ù§Ô∏è package.</p>
<p>We create a <a href="https://graphql.org/">GraphQL</a> API using the <code>@nestjs/graphql</code>. You will learn how to write the API with TypeScript using the <strong>code first</strong> approach and the new <a href="https://docs.nestjs.com/graphql/resolvers#cli-plugin">GraphQL plugin</a>.</p>
<p>In this guide we are using <a href="https://prisma.io">Prisma</a> to easily access a database. You can follow this guide to setup a <a href="https://notiz.dev/blog/how-to-connect-nestjs-with-prisma">Nest application with Prisma</a> as Prisma is out of scope for this guide.</p>
<h2 id="setupgraphql">Setup GraphQL</h2>
<p>To start a GraphQL API install the following packages into your Nest application.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm i --save @nestjs/graphql graphql-tools graphql

# for Express
npm i --save apollo-server-express
# for Fastify
npm i --save apollo-server-fastify
</code></pre>

</div>
<p>Import the <code>GraphQLModule</code> into your <code>AppModule</code>.</p>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { join } from 'path';

@Module({
  imports: [
    GraphQLModule.forRoot({
      autoSchemaFile: join(process.cwd(), 'src/schema.gql'),
      debug: true,
      playground: true
    })
  ]
})
export class AppModule {}
</code></pre>

</div>
<p>To configure the GraphQL endpoint we use <code>GqlModuleOptions</code> which are passed to the underlying GraphQL server. Here we are enabling the <a href="https://docs.nestjs.com/graphql/quick-start#code-first"><strong>code first</strong></a> approach.</p>
<ul>
<li><code>autoSchemaFile</code> enables the <strong>code first</strong> approach to use TypeScript classes and decorators to generate the GraphQL schema.</li>
<li><code>playground</code> enables the <a href="https://github.com/prisma-labs/graphql-playground">GraphQL Playground</a>, an interactive IDE for your API documentation, available at <a href="http://localhost:3000/graphql">http://localhost:3000/graphql</a>.</li>
<li><code>debug</code> mode</li>
</ul>
<p>There are two options for <code>autoSchemaFile</code> providing a <strong>path</strong> for the schema generation or <code>true</code> for generating the schema in memory.</p>
<h2 id="graphqlcodefirstapproach">GraphQL Code First approach</h2>
<p>A GraphQL schema contains many <a href="https://graphql.org/learn/schema/">types</a> and <a href="https://graphql.org/learn/queries/">Queries</a>. The schema grows in size and complexity for each new query, mutation and type. GraphQL <a href="https://www.youtube.com/watch?v=OloBAdNCnyQ"><strong>Code First</strong></a> enables us to automatically generate a GraphQL schema using TypeScript and decorators. This helps us focus on writing <code>.ts</code> files and we don't need to write the GraphQL schema ourselves.</p>
<p><code>@nestjs/graphql</code> provides all decorators to generate our schema. Here are a few decorators and there usage:</p>
<ul>
<li><code>@ObjectType()</code> generate class as <a href="https://graphql.org/learn/schema/#type-system">Type</a></li>
<li><code>@Field()</code> generate a class property as a <a href="https://graphql.org/learn/schema/#object-types-and-fields">Field</a></li>
<li><code>@InputType()</code> generate class as <a href="https://graphql.org/learn/schema/#input-types">Input</a></li>
<li><code>@Args</code> generate method params as <a href="https://graphql.org/learn/schema/#arguments">Arguments</a></li>
<li><code>@Query()</code> generate method as <a href="https://graphql.org/learn/schema/#the-query-and-mutation-types">Query</a></li>
<li><code>@Mutation()</code> generate method as <a href="https://graphql.org/learn/schema/#the-query-and-mutation-types">Mutation</a></li>
<li><code>@ResolveField</code> resolve relationship property</li>
</ul>
<h3 id="graphqltype">GraphQL Type</h3>
<p>Start with creating your objects as a TypeScript <code>class</code>.</p>
<div shortcode="code" tabs="user.ts,hobby.ts">
<pre><code class="ts language-ts">export class User {
  id: number;
  createdAt: Date;
  updatedAt: Date;
  email: string;
  password: string;
  name?: string;
  hobbies: Hobby[];
}
</code></pre><pre><code class="ts language-ts">export class Hobby {
  id: number;
  name: string;
}
</code></pre>

</div>
<p>Let's add <a href="https://docs.nestjs.com/graphql/resolvers#code-first">decorators</a> to expose this model in our GraphQL schema. Start adding <code>@ObjectType()</code> to the TypeScript class.</p>
<div shortcode="code" tabs="user.ts,hobby.ts">
<pre><code class="ts language-ts">import { ObjectType } from '@nestjs/graphql';

@ObjectType()
export class User {
  ...
}
</code></pre><pre><code class="ts language-ts">@ObjectType()
export class Hobby {
  ...
}
</code></pre>

</div>
<p>Next we use the <code>@Field</code> decorator on each class property providing additional information about the type and state (required or optional).</p>
<div shortcode="code" tabs="user.ts,hobby.ts">
<pre><code class="ts language-ts">import { ObjectType, Field, Int } from '@nestjs/graphql';

@ObjectType()
export class User {
  @Field(type =&gt; Int)
  id: number;

  @Field(type =&gt; Date, { name: 'registeredAt' })
  createdAt: Date;

  @Field(type =&gt; Date)
  updatedAt: Date;

  @Field(type =&gt; String)
  email: string;

  password: string;

  @Field(type =&gt; String, { nullable: true })
  name?: string;

  @Field(type =&gt; [Hobby])
  hobbies: Hobby[];
}
</code></pre><pre><code class="ts language-ts">@ObjectType()
export class Hobby {
  @Field(type =&gt; Int)
  id: number;

  @Field(type =&gt; String)
  name: string;
}
</code></pre>

</div>
<p>The following GraphQL type is generated if this class is used in a resolver.</p>
<div shortcode="code" tabs="schema.gql">
<pre><code class="graphql language-graphql">type User {
  id: Int!
  registeredAt: DateTime!
  updatedAt: DateTime!
  email: String!
  name: String
  hobbies: [Hobby!]!
}
</code></pre>

</div>
<ul>
<li><code>@Field</code> takes an optional type function (e.g. <code>type =&gt; String</code>)</li>
<li>Declare a field as an array using the bracket notation <code>[ ]</code> in the type function (e.g. <code>type =&gt; [Hobby]</code>)</li>
<li>Optional <code>FieldOptions</code> object to change the generated schema</li>
<li><code>name</code>: property name in the schema (<code>createdAt</code> =&gt; <code>registeredAt</code>)</li>
<li><code>description</code>: adding a field description</li>
<li><code>deprecationReason</code>: adding a deprecation notice</li>
<li><code>nullable</code>: declare a field is required or optional</li>
<li>Hide properties from the schema by omitting <code>@Field</code></li>
</ul>
<p>For more details head over to the NestJS <a href="https://docs.nestjs.com/graphql/resolvers#object-types">docs</a>!</p>
<p>We have added a bit of boilerplate to our <code>User</code> model and other models we will create. Nest provides a CLI plugin to reduce the boilerplate of our models. Check out the GraphQL plugin section on how to reduce the boilerplate.</p>
<h3 id="graphqlresolver">GraphQL Resolver</h3>
<p>Great our models are in place! Now we use the Nest CLI to generate our resolvers.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">nest generate resolver &lt;name&gt;

# alias
nest g r &lt;name&gt;

# User and Hobby
nest g r user
nest g r hobby
</code></pre>

</div>
<p>Our resolvers are added to the <code>providers</code> array in the <code>app.module.ts</code>.</p>
<div shortcode="code" tabs="user.resolver.ts">
<pre><code class="ts language-ts">import { Resolver } from '@nestjs/graphql';
import { User } from '../models/user.model';

@Resolver(of =&gt; User)
export class UserResolver {
  ...
}
</code></pre>

</div>
<p>Declare a <code>of</code> function in the <code>@Resolver</code> decorator (e.g. <code>@Resolver(of =&gt; User)</code>) this is used to provide a parent object in <code>@ResolveField</code>. We will cover <code>@ResolveField</code> in a bit.</p>
<p>Add <code>@Query</code> to your resolvers to create new GraphQL queries in your schema. Let's create a query function returning all <code>users()</code>. Use the bracket notation inside the decorator <code>@Query(returns =&gt; [User])</code> to declare an array return value.</p>
<div shortcode="note">
Prisma is used in this example, but can be replaced easily with an ORM of your choice like [TypeORM](https://docs.nestjs.com/recipes/sql-typeorm), [Mongoose](https://docs.nestjs.com/recipes/mongodb) or [Sequelize](https://docs.nestjs.com/recipes/sql-sequelize). See the full database setup in the [example repo](https://github.com/notiz-dev/nest-graphql-code-first).
</div>
<div shortcode="code" tabs="user.resolver.ts">
<pre><code class="ts language-ts">import { Resolver, Query } from '@nestjs/graphql';
import { User } from '../models/user.model';
import { PrismaService } from '../prisma/prisma.service';

@Resolver(of =&gt; User)
export class UserResolver {
  constructor(private prisma: PrismaService) {}

  @Query(returns =&gt; [User])
  async users() {
    return this.prisma.user.findMany();
  }
}
</code></pre>

</div>
<p>The above code generates the following query to our schema:</p>
<div shortcode="code" tabs="schema.gql">
<pre><code class="graphql language-graphql">type Query {
  users: [User!]!
}
</code></pre>

</div>
<p>A <code>User</code> has a relation to many hobbies. To resolve the <code>hobbies</code> property from a user, we make use of the <code>@ResolveField</code> decorator. Add <code>@ResolveField</code> to a function with the <strong>exact</strong> same name of the property we want to resolve. Here we add a <code>hobbies()</code> function and provide a <code>User</code> object as the parent.</p>
<div shortcode="code" tabs="user.resolver.ts">
<pre><code class="ts language-ts">import { Resolver, Query, ResolveField, Parent } from '@nestjs/graphql';
import { User } from '../models/user.model';
import { PrismaService } from '../prisma/prisma.service';

@Resolver(of =&gt; User)
export class UserResolver {
  constructor(private prisma: PrismaService) {}

  @Query(returns =&gt; [User])
  async users() {
    return this.prisma.user.findMany();
  }

  @ResolveField()
  async hobbies(@Parent() user: User) {
    return this.prisma.hobby.findMany({
      where: { user: { id: user.id } }
    });
  }
}
</code></pre>

</div>
<p>Use the parent object to query the relationship object from a database or another endpoint.</p>
<h3 id="testgraphqlapi">Test GraphQL API</h3>
<p>Start your Nest application and navigate to the <a href="http://localhost:3000/graphql">playground</a>, it is available if <code>playground</code> is set to <code>true</code> in the <code>GraphQLModule</code>.</p>
<p>The playground shows us our GraphQL schema and the docs for our queries.</p>
<div shortcode="figure" caption="GraphQL Playground schema view">

![GraphQL Playground schema view](assets/img/blog/graphql-code-first-with-nestjs-7/optimized/graphql-playground-schema.png)

</div>
<p>Additionally, we can "play" with queries inside the playground. Try out the <strong>autocomplete</strong> feature in the playground to create your own queries based on your schema and queries.
Let's query all users using the following query:</p>
<div shortcode="code" tabs="schema.gql">
<pre><code class="graphql language-graphql">query AllUsers {
  users {
    id
    registeredAt
    updatedAt
    email
    name
    hobbies {
      id
      name
    }
  }
}
</code></pre>

</div>
<p>The response will look like this with a different data set. I prepared the database with a few dummy users and hobbies.</p>
<div shortcode="figure" caption="Users query in GraphQL Playground">

![Users query in GraphQL Playground](assets/img/blog/graphql-code-first-with-nestjs-7/optimized/users-query.png)

</div>
<h2 id="graphqlplugin">GraphQL plugin</h2>
<p>Nest 7 provides a new <a href="https://docs.nestjs.com/graphql/resolvers#cli-plugin">GraphQL plugin</a> to reduce the boilerplate of decorators for our <strong>models</strong>, <strong>inputs</strong>, <strong>args</strong> and <strong>entity</strong> files. Enable the plugin by adding <code>compilerOptions</code> to <code>nest-cli.json</code>:</p>
<div shortcode="code" tabs="nest-cli.json">
<pre><code class="json language-json">{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "plugins": ["@nestjs/graphql/plugin"]
  }
}
</code></pre>

</div>
<p>The plugin automatically handles the decorators for the files with the suffix <code>['.input.ts', '.args.ts', '.entity.ts', '.model.ts']</code>. If you like to use custom suffixes add those to the plugins option:</p>
<div shortcode="code" tabs="nest-cli.json">
<pre><code class="json language-json">"plugins": [
  {
    "name": "@nestjs/graphql/plugin",
    "options": {
      "typeFileNameSuffix": [".input.ts", ".model.ts"]
    }
  }
]
</code></pre>

</div>
<p>Let's clean up the boilerplate of our models. Before the plugin the models look like this:</p>
<div shortcode="code" tabs="user.ts,hobby.ts">
<pre><code class="ts language-ts">import { ObjectType, Field, Int } from '@nestjs/graphql';
import { Hobby } from './hobby.model';

@ObjectType()
export class User {
  @Field(type =&gt; Int)
  id: number;

  @Field(type =&gt; Date, { name: 'registeredAt' })
  createdAt: Date;

  @Field(type =&gt; Date)
  updatedAt: Date;

  @Field(type =&gt; String)
  email: string;

  password: string;

  @Field(type =&gt; String, { nullable: true })
  name?: string;

  @Field(type =&gt; [Hobby])
  hobbies: Hobby[];
}
</code></pre><pre><code class="ts language-ts">@ObjectType()
export class Hobby {
  @Field(type =&gt; Int)
  id: number;

  @Field(type =&gt; String)
  name: string;
}
</code></pre>

</div>
<p>After removing the extra boilerplate decorators the models looks like this:</p>
<div shortcode="code" tabs="user.ts,hobby.ts">
<pre><code class="ts language-ts">import { ObjectType, Field, Int, HideField } from '@nestjs/graphql';
import { Hobby } from './hobby.model';

@ObjectType()
export class User {
  @Field(type =&gt; Int)
  id: number;

  @Field({ name: 'registeredAt' })
  createdAt: Date;

  updatedAt: Date;

  email: string;

  @HideField()
  password: string;

  name?: string;

  hobbies: Hobby[];
}
</code></pre><pre><code class="ts language-ts">@ObjectType()
export class Hobby {
  @Field(type =&gt; Int)
  id: number;

  name: string;
}
</code></pre>

</div>
<div shortcode="note">
Hiding properties from the schema requires the `@HideField` decorator.
</div>
<p>We can add <code>@Field</code> to any property to override the documentation and also the inferred type.
For example <code>number</code> is inferred as the GraphQL type <code>Float</code> here we can use <code>@Field(type =&gt; Int)</code> to change this to an <code>Int</code> type.</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Angular Elements: Create a Component Library for Angular and the Web]]></title>
        <id>/blog/create-a-component-library-for-angular-and-the-web</id>
        <link href="https://notiz.dev/blog/create-a-component-library-for-angular-and-the-web"/>
        <updated>2020-03-25T10:12:00.000Z</updated>
        <summary type="html"><![CDATA[Publish Angular components and Custom Elements from a single project! Using the Angular CLI.]]></summary>
        <content type="html"><![CDATA[<p>Reuse your <strong>Angular components</strong> almost everywhere - with <a href="https://angular.io/guide/elements">Angular Elements</a>.</p>
<p>In this guide you'll learn how to</p>
<ul>
<li>Scaffold a reusable component library.</li>
<li>Export the library for <strong>Angular</strong> and as <strong><a href="https://www.webcomponents.org/">Web Components</a></strong>.</li>
<li>Publish everything to <strong>npm</strong>.</li>
</ul>
<p>Let's get started. ‚¨á</p>
<h2 id="createtheproject">Create the project</h2>
<p>This guide uses the <a href="https://cli.angular.io/">Angular CLI 9.0.7</a> to scaffold most of the project structure and configuration for your <strong>reusable UI Library</strong>.</p>
<p>First, initialize a new Angular application with  <code>ng new APP_NAME</code>. Feel free to use routing and your favorite stylesheet format when prompted.</p>
<p>Open the newly created project in your favorite IDE.</p>
<p>Next, run: </p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng g library components
</code></pre>

</div>
<p>This step will generate a new <strong>library</strong> under <code>./projects/components</code> and add an example component. The library is ready to be shared and used in all of your Angular applications without further configuration. üíÜ</p>
<p>Perform an initial build of the component library by running: </p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng build components
</code></pre>

</div>
<div shortcode="note">

Currently, **Angular Elements** only supports projects of type `application` to create Custom Elements. This means you need to generate an _additional_ application. The sole purpose of the application is to import your angular components and output them as Custom Elements.

</div>
<p>To generate the elements application run:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng g application elements
</code></pre>

</div>
<p>Additionally, run the <code>@angular/elements</code> schematic:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">ng add @angular/elements --project elements
</code></pre>

</div>
<p>This will create a new app in the subfolder <code>./projects/elements</code> and install all the necessary dependencies and polyfills needed to set up Angular Elements.</p>
<p>If you want to publish your components as Custom Elements cd into <code>./projects/elements</code> and create a package.json using </p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm init
</code></pre>

</div>
<p>Then, add the following to the newly created <strong>package.json</strong>:</p>
<div shortcode="code" tabs="package.json">
<pre><code class="js language-js">{
  ...
  "files": ["elements.js", "styles.css"],
  ...
}
</code></pre>

</div>
<p>Your project should now look something like this:</p>
<div shortcode="figure" caption="folder structure and package.json content">

![folder structure and package.json content](assets/img/blog/create-a-component-library-for-angular-and-the-web/optimized/structure.png)

</div>
<h2 id="configureangularelements">Configure Angular Elements</h2>
<p>In the elements application delete all files in <code>./projects/elements/src/app</code> except <code>app.module.ts</code>.</p>
<p>You need to define your own bootstrapping method for the elements application.
Do some changes to your elements <code>app.module.ts</code>:</p>
<ul>
<li>Remove the bootstrap array from <code>NgModule</code> declaration.</li>
<li>Import <code>ComponentsModule</code> and <code>ComponentsComponent</code> from the components library.</li>
<li>Add <code>ngDoBootstrap</code> hook.</li>
<li>For every component create an element using the <code>createCustomElement</code> function from <code>@angular/elements</code>. Then define the element using web's native <code>customElemments.define</code> function, specifying a selector.</li>
</ul>
<div shortcode="code" tabs="app.module.ts">
<pre><code class="typescript language-typescript">import { BrowserModule } from '@angular/platform-browser';
import { NgModule, Injector } from '@angular/core';
import { createCustomElement } from '@angular/elements';
import { ComponentsModule, ComponentsComponent } from 'components';

@NgModule({
  imports: [
    BrowserModule,
    ComponentsModule
  ],
  providers: []
})
export class AppModule {

  constructor(private injector: Injector){}

  ngDoBootstrap(){
    const element = createCustomElement(ComponentsComponent, { injector: this.injector })
    customElements.define("lib-components", element);
  }

 }
</code></pre>

</div>
<div shortcode="note">

### Remove zone.js (optional)
Removing `zone.js` is probably a good idea. Read more about it [in this great article](https://www.angulararchitects.io/aktuelles/angular-elements-part-iii/). Just keep in mind that you need to handle [change detection](https://angular.io/api/core/ChangeDetectorRef) yourself.

</div>
<div shortcode="code" tabs="main.ts">
<pre><code class="typescript language-typescript">import { enableProdMode } from '@angular/core';
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppModule } from './app/app.module';
import { environment } from './environments/environment';

if (environment.production) {
  enableProdMode();
}

platformBrowserDynamic()
  .bootstrapModule(AppModule, { ngZone: 'noop' })
  .catch(err =&gt; console.error(err));
</code></pre>

</div>
<h2 id="timetobuild">Time to build ‚öô</h2>
<p>In your root package.json add the following scripts:</p>
<div shortcode="code" tabs="package.json">
<pre><code class="js language-js">{
  "scripts": {
    ...
    "build:elements": "ng build --prod --project elements --output-hashing none &amp;&amp; npm run pack:elements &amp;&amp; cp projects/elements/package.json dist/elements",
    "pack:elements": "cat ./dist/elements/{runtime,polyfills,main}-es5.js &gt; dist/elements/elements.js &amp;&amp; ls -lah dist/elements/elements.js",
    "build:components": "ng build --prod --project components",
    ...
  },
  ...

}
</code></pre>

</div>
<p>To build the elements application run: </p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run build:elements
</code></pre>

</div>
<p>The script exports your Angular components as Custom Elements during the build process. Also it will run the <code>pack:elements</code> script and copy the previously created <code>package.json</code> to <code>./dist/elements</code>.</p>
<div shortcode="note">

The `pack:elements` script is optional yet very useful because it will bundle the js build outputs into a single `elements.js` file. This makes it easier to include your library in other applications.

</div>
<h2 id="tryitout">Try it out</h2>
<p>Use your Angular components by including them in the root Angular application:</p>
<div shortcode="code" tabs="app.module.ts,app.component.html">
<pre><code class="typescript language-typescript">import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppComponent } from './app.component';
import { ComponentsModule } from 'components';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    ComponentsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre><pre><code class="html language-html">&lt;h1&gt;angular component&lt;/h1&gt;
&lt;lib-components&gt;&lt;/lib-components&gt;
</code></pre>

</div>
<p>Run the root application with <code>ng s</code>.</p>
<div shortcode="figure" caption="Angular app running and displaying the component">

![angular app running and displaying the component](assets/img/blog/create-a-component-library-for-angular-and-the-web/optimized/angular-component.png)

</div>
<p>Using your Custom Elements is simple. Create an index.html in the root of your project and add following code snippet:</p>
<div shortcode="code" tabs="index.html">
<pre><code class="html language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link rel="stylesheet" href="dist/elements/styles.css"&gt;
    &lt;script src="dist/elements/elements.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;h1&gt;Web Component (Costum Elements)&lt;/h1&gt;
    &lt;lib-components&gt;&lt;/lib-components&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

</div>
<p>To test, serve it on a http server and open the index.html. I'm using <a href="https://www.npmjs.com/package/serve">serve</a>.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">serve .
</code></pre>

</div>
<div shortcode="figure" caption="Web Component result">

![web component](assets/img/blog/create-a-component-library-for-angular-and-the-web/optimized/custom-element.png)

</div>
<h2 id="publishtonpm">Publish to npm</h2>
<p>The only thing left to do is to publish your components and Custom Elements to npm.
This is fairly easy. Either run <code>npm publish dist/components</code> or <code>npm publish dist/elements</code>.</p>
<div shortcode="note" type="warn">

### Reminder
Before releasing, you probably want to update `./projects/components/package.json` and `./projects/elements/package.json` to include your libraries' name and version. A way to name your libraries could be `ngx-<NAME>` for angular and `wc-<NAME>` for the Custom Elements.

</div>
<p>‚ú® Congratulations! You successfully created and published a custom Angular component library that can be used almost everywhere!</p>
<p>If you have further questions on the topic, feedback on the article or just want to say hi you can hit me up on <a href="https://twitter.com/garygrossgarten">twitter</a>.</p>]]></content>
        <author>
            <name>Gary Gro√ügarten</name>
        </author>
        <contributor>
            <name>gary-gro√ügarten</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to manage multiple Node.js versions on macOS X]]></title>
        <id>/blog/how-to-manage-multiple-node-versions-on-mac</id>
        <link href="https://notiz.dev/blog/how-to-manage-multiple-node-versions-on-mac"/>
        <updated>2020-03-19T18:13:00.000Z</updated>
        <summary type="html"><![CDATA[How to manage multiple Node.js versions on macOS X using homebrew.]]></summary>
        <content type="html"><![CDATA[<p>Here is a quick tip on how to install multiple <a href="https://nodejs.org/en/">Node.js</a> versions (10, 12, 13 etc.) on macOS X and how to switch between them for your applications.</p>
<h2 id="installingnodeviahomebrew">Installing Node via Homebrew</h2>
<p>Install multiple Node versions using <a href="https://brew.sh/">Homebrew</a>. To install Homebrew run:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
</code></pre>

</div>
<p>Now install the Node versions you need using <code>brew</code>:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">brew install node@&lt;version&gt;

# latest version
brew install node

# LTS 12
brew install node@12

# 10
brew install node@10
</code></pre>

</div>
<p>To check the default node version and installation path:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">node -v # v13.11.0
which node # /usr/local/bin/node =&gt; /usr/local/opt/node@&lt;version&gt;/bin/node
</code></pre>

</div>
<h2 id="switchnodeviaalias">Switch Node via alias</h2>
<p>Add an alias to your <code>.zshrc</code> or <code>.bash_profile</code> for each installed Node version. Node is installed at <code>/usr/local/opt/node@&lt;version&gt;/bin</code></p>
<div shortcode="code" tabs=".zshrc/.bash_profile">
<pre><code class="bash language-bash">alias node13='export PATH="/usr/local/opt/node@13/bin:$PATH"'
alias node12='export PATH="/usr/local/opt/node@12/bin:$PATH"'
alias node10='export PATH="/usr/local/opt/node@10/bin:$PATH"'
</code></pre>

</div>
<p>Now, to switch between the node versions, enter an alias <code>node10</code> in your terminal. Execute <code>node -v</code> to verify that you are now using the correct node version.</p>
<div shortcode="note">
Alias **only** changes the Node version in the used terminal instance
</div>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Build and publish your first GitHub Action]]></title>
        <id>/blog/build-and-publish-your-first-github-action</id>
        <link href="https://notiz.dev/blog/build-and-publish-your-first-github-action"/>
        <updated>2020-03-17T10:12:00.000Z</updated>
        <summary type="html"><![CDATA[Build your first GitHub Action and deploy it to the Marketplace - Using TypeScript üíô]]></summary>
        <content type="html"><![CDATA[<p>If you are using GitHub you most likely already heard about <a href="https://github.com/features/actions">GitHub Actions</a>. With GitHub Actions you can fulfill all of your CI/CD dreams right where your code lives. You do this by defining <strong>jobs</strong> that run a series of <strong>Actions</strong> - The building blocks of your repository workflows. This enables you to stay productive even when managing multiple projects at once. üë®‚Äçüíª</p>
<p>In this short guide you will learn how to create your first GitHub Action and publish it on the <a href="https://github.com/marketplace">GitHub Marketplace</a>! üíô</p>
<h2 id="quickstart">Quickstart</h2>
<p>To get started quickly, you can initialize your own Action repository by generating it from <a href="https://github.com/notiz-dev/github-action-template">GitHub Action Template</a>. For the sake of simplicity this repository is a minimized version of the official <a href="https://github.com/actions/typescript-action">typescript action template</a>. You are free to choose which starter you want to use. The steps to build and release your Action will essentially remain the same.</p>
<p>Visit <a href="https://github.com/notiz-dev/github-action-template">GitHub Action Template</a> and click on <strong><a href="https://github.com/notiz-dev/github-action-template/generate">Use this template</a></strong>.</p>
<div shortcode="figure" caption="Use this template on GitHub">

![Use this template on GitHub](assets/img/blog/build-and-publish-your-first-github-action/optimized/template.png)

</div>
<p>Fill out the form and click on <strong>Create repository from template</strong>.</p>
<div shortcode="figure" caption="Create Repository from template">

![Create Repository from template](assets/img/blog/build-and-publish-your-first-github-action/optimized/create_repository.png)

</div>
<p>Next clone your newly created repository and open it with your favorite IDE.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">git clone git@github.com:&lt;USERNAME/ORG&gt;/&lt;REPOSITORY&gt;.git`

# Install all dependencies
npm i
</code></pre>

</div>
<p>Great! Everything is set up! üöÄ In the next section of this guide you'll get an overview of the most important files.</p>
<h2 id="templateoverview">Template Overview</h2>
<p>First, inspect <code>index.ts</code>:</p>
<div shortcode="figure" caption="main project files">

![main project files](assets/img/blog/build-and-publish-your-first-github-action/optimized/overview.png)

</div>
<p>The template Action is a simple script that receives an input string and outputs a hello world like greeting. (E.g. input <code>World</code> ‚û° output <code>Hello World</code>). 
See how the <code>actions/core</code> api is being used to receive the value of the <code>my_input</code> input and to set the resulting string as an output. Also, <code>setFailed</code> can be called to set the running workflow as failed and stop the execution. <a href="https://www.npmjs.com/package/@actions/core">API Documentation</a></p>
<p>Most toolkit and CI/CD operations involve async operations so your <code>run</code> function will most likely be async.
Second, see <code>action.yml</code> in the root of your project.</p>
<div shortcode="code" tabs="TS,action.yml">
<pre><code class="typescript language-typescript">import * as core from '@actions/core';

async function run() {
  try {
    await asyncFunction();
  } catch (err) {
    core.setFailed(err.message);
  }
}

run();
</code></pre><pre><code class="yaml language-yaml">name: 'GitHub Action Template'
description: 'simple typescript template for building GitHub Actions'
author: 'notiz.dev'
inputs:
  my_input:
    description: 'input description here'
    default: 'World'
runs:
  using: 'node12'
  main: 'dist/index.js'
branding:
  color: 'yellow'
  icon: 'bell'
</code></pre>

</div>
<p>The <code>action.yml</code> file defines some metadata that is mandatory to run and publish your Action on GitHub. 
Besides general information like name, description and author, you'll want to define all the necessary inputs for your Action. The entrypoint of the Action is set to run <code>dist/index.js</code> using version 12 of node. This file will be created once you build and pack the project. </p>
<p>To publish the Action, you additionally need to define a branding for how your Action appears on the GitHub Marketplace. 
For more information on the configuration of your Action see <a href="https://help.github.com/en/actions/building-actions/metadata-syntax-for-github-actions">Metadata syntax for GitHub Actions</a>.</p>
<p>Lastly, you'll find a workflow file under <code>.github/workflows/test.yml</code>.</p>
<div shortcode="code" tabs="test.yml">
<pre><code class="yaml language-yaml">name: 'test'
on: # rebuild any PRs and main branch changes
  pull_request:
  push:
    branches:
      - master
      - 'releases/*'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
    - name: run action
      id: run_action
      uses: ./
      with: 
        my_input: 'World'

    - name: log action output
      run: echo ${{steps.run_action.outputs.my_output}}     
</code></pre>

</div>
<p>Essentially, this will start a workflow testing your Action on every push to <code>master/release</code> or on PRs. The <code>test</code> job will checkout and run your Action, defining <code>World</code> as the input value for <code>my_input</code>. </p>
<p>Finally, the <code>log action output</code> step of your job will echo the output set by your GitHub Action. Note the id that is defined in the <code>run action</code> step and later used to retrieve the output value.</p>
<p>By creating your repository from the template earlier, the workflow already got invoked once:</p>
<div shortcode="figure" caption="invoked workflow">

![invoked workflow](assets/img/blog/build-and-publish-your-first-github-action/optimized/workflow.png)

</div>
<div shortcode="figure" caption="workflow result">

![workflow result](assets/img/blog/build-and-publish-your-first-github-action/optimized/workflow_result.png)

</div>
<p>As you can see in the image above, the <code>log action output</code> step successfully echoed <code>Hello World</code> to the console.</p>
<h2 id="implementtheaction">Implement the Action</h2>
<p>Next, the fun part! üôã </p>
<p>Implement your own TypeScript code in <code>src/index.ts</code>. Just remember to update the <code>action.yml</code> and the test workflow <code>.github/workflows/test.yml</code> before pushing your changes. You can obviously do everything you want here. Feel free to install other libraries via npm.</p>
<p>To build changes to your TypeScript code run:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run build
</code></pre>

</div>
<p>This will compile your TypeScript to a lib folder.</p>
<p>Next, run:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm run pack
</code></pre>

</div>
<p>This script will bundle your lib together with the required production node_modules. The bundled package can now be found in the <code>dist</code> folder containing the <code>index.js</code> that's been declared as the entrypoint in your <code>action.yml</code>.</p>
<p>See <a href="https://github.com/notiz-dev/github-action-json-property">JSON Property GitHub Action</a> for another example.</p>
<h2 id="publishtogithubmarketplace">Publish to GitHub Marketplace</h2>
<p>After you built and packed the Action you are ready to commit and push your changes to the GitHub Repository. You should definitely add a <strong>README</strong> with instructions on how to use your Action.</p>
<p>Check if your test workflow is working as expected. If you are happy with the results, you are ready to finally publish your Action to the Marketplace.</p>
<p>Hit the <strong>release</strong> tab of your repository to create a new version of your Action.</p>
<div shortcode="figure" caption="create release">

![create release](assets/img/blog/build-and-publish-your-first-github-action/optimized/create_release.png)

</div>
<p>Click on <strong>Create a new release</strong> and select <strong>Publish this Action to the GitHub Marketplace</strong>.</p>
<div shortcode="figure" caption="publish to marketplace">

![publish to marketplace](assets/img/blog/build-and-publish-your-first-github-action/optimized/publish.png)

</div>
<p>Check if all requirements are checked and proceed to file the release.</p>
<div shortcode="figure" caption="publish to marketplace">

![publish to marketplace](assets/img/blog/build-and-publish-your-first-github-action/optimized/release.png)

</div>
<p><br></p>
<p>Enter a <strong>tag</strong> and <strong>release</strong> title. Optionally specify a release description before clicking <strong>Publish release</strong>.</p>
<div shortcode="note">

To make it easy for users to always use the latest release of your Action you can tag the newly created version with a `release` tag. Next time you release a version you can move the `release` tag from the previous to the latest version.

</div>
<h2 id="usingyouraction">Using your Action</h2>
<p>By now you should have a published version of your Action on the GitHub Marketplace.</p>
<p>You should see the Marketplace banner on your repository page:</p>
<div shortcode="figure" caption="GitHub Marketplace">

![marketplace banner](assets/img/blog/build-and-publish-your-first-github-action/optimized/marketplace_banner.png)

</div>
<p>Inspect the Action entry in GitHub Marketplace:</p>
<div shortcode="figure" caption="Marketplace entry">

![marketplace entry](assets/img/blog/build-and-publish-your-first-github-action/optimized/marketplace.png)

</div>
<p>Use your Action by creating a <strong>workflow</strong> file in a repository of your choice. In case you tagged the version with the <code>release</code> tag, include your Action as follows:</p>
<div shortcode="code" tabs="workflow">
<pre><code class="yaml language-yaml">...

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: run action
      id: run_action
      uses: &lt;USERNAME/ORG&gt;/&lt;REPOSITORY&gt;@release
      with: 
        my_input: 'World'

    - name: log action output
      run: echo ${{steps.run_action.outputs.my_output}} 

...    
</code></pre>

</div>
<p>Please replace <code>&lt;USERNAME/ORG&gt;</code> and <code>&lt;REPOSITORY&gt;</code> with your repository details.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Awesome, you made it to the end of this guide. üéâ</p>
<p>As you could see, building and publishing your first GitHub Action is fairly straightforward. To not double the efforts of building certain Actions you should check the <a href="https://github.com/marketplace">Marketplace</a> and <a href="https://github.com/sdras/awesome-actions">this awesome list</a>.</p>
<p>If you have further questions on the topic, feedback on the article or just want to say hi you can hit me up on <a href="https://twitter.com/garygrossgarten">twitter</a>.</p>]]></content>
        <author>
            <name>Gary Gro√ügarten</name>
        </author>
        <contributor>
            <name>gary-gro√ügarten</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deploy NestJS with Prisma to Heroku]]></title>
        <id>/blog/deploy-nestjs-with-prisma-to-heroku</id>
        <link href="https://notiz.dev/blog/deploy-nestjs-with-prisma-to-heroku"/>
        <updated>2021-11-09T15:00:00.000Z</updated>
        <summary type="html"><![CDATA[Deploy a NestJS application with Prisma 2.0 to Heroku and connect to a PostgreSQL database.]]></summary>
        <content type="html"><![CDATA[<p>You will learn how to deploy a NestJS application with Prisma 2.0 to <a href="https://www.heroku.com/">Heroku</a> üöÄ. Also we will create a <a href="https://dev.to/prisma/how-to-setup-a-free-postgresql-database-on-heroku-1dc1">PostgreSQL database on Heroku</a> and connect it with Prisma.</p>
<p>Check out my previous tutorial to create a <code>PrismaService</code> for your Nest application.</p>
<div shortcode="article" routes="/blog/how-to-connect-nestjs-with-prisma"></div>
<h2 id="preparingnestapplicationforheroku">Preparing Nest application for Heroku</h2>
<p>Let's get started by preparing our Nest application to run on Heroku.</p>
<p>First, we modify <code>main.ts</code> to use the port provided by Heroku as an environment variable. CORS can also be enabled for web or mobile applications making requests to the Nest application.</p>
<div shortcode="code" tabs="main.ts">
<pre><code class="typescript language-typescript">import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors();
  await app.listen(process.env.PORT || 3000);
}
bootstrap();
</code></pre>

</div>
<p>Heroku takes care of installing our <strong>node_modules</strong> for us. Before Heroku can start our Nest application using <code>npm run start:prod</code>, we need to generate the <code>PrismaClient</code> and build our app. We add <code>"postinstall": "npx prisma generate &amp;&amp; npm run build",</code> to the <strong>scripts</strong> in our <strong>package.json</strong> which generates a new <code>PrismaClient</code> and performs the app build, creating our <code>dist</code> folder.</p>
<p>Heroku needs to know how to execute our Nest application via a <code>Procfile</code>. Create a <code>Procfile</code> in the root folder with our start script <code>web: npm run start:prod</code>. Now Heroku will install our dependencies, generate Prisma Client and build the application in the <strong>postinstall</strong> script and then start the application.</p>
<h2 id="newherokuappandcli">New Heroku app and CLI</h2>
<p>Next, sign up or log into your <a href="https://id.heroku.com/login">Heroku account</a>. Create a new Heroku app by clicking on <strong>New</strong> and then <strong>Create new app</strong>.</p>
<p>Choose an app name to identify your app and the name is also used as your default api endpoint at <strong>https://your-app-name.herokuapp.com/</strong>. You can also choose between two regions for your app <strong>United States</strong> and <strong>Europe</strong>.</p>
<div shortcode="figure" caption="Create new Heroku app">

![Create new Heroku app](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/create-new-app.png)

</div>
<div shortcode="note">

Heroku let's you configure a custom domain in your app settings.

</div>
<p>Alright, our heroku app is set up.</p>
<div shortcode="figure" caption="Deploy using Heroku Git">

![Deploy using Heroku Git](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/deploy-using-heroku-git.png)

</div>
<p>We install the <a href="https://devcenter.heroku.com/articles/heroku-cli#download-and-install">Heroku CLI</a> and deploy our Nest application by pushing to Heroku git.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">heroku login

cd your-nest-app
heroku git:remote -a your-app-name

git push heroku master
</code></pre>

</div>
<p>After pushing our current application to Heroku, we see the following output in our terminal or in the <strong>Activity</strong> tab of our Heroku app.</p>
<div shortcode="figure" caption="First app build on Heroku">

![First app build on Heroku](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/first-build.png)

</div>
<p>Heroku prints <strong>Build succeeded!</strong> and our application link at the end like <a href="https://nestjs-prisma-heroku.herokuapp.com/">https://nestjs-prisma-heroku.herokuapp.com/</a>.</p>
<p>Let's visit our app by either clicking on the link or on <strong>Open app</strong> in the toolbar.</p>
<p>I am seeing <strong>Hello World!</strong>. The Nest app has been successfully deployed to Heroku üéâ</p>
<div shortcode="figure" caption="Hello World">

![Hello World!](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/first-app-launch.png)

</div>
<p>In the next step we will setup a PostgreSQL database and use Prisma Migrate to apply our database schema.</p>
<h2 id="setuppostgresqlanduseprismamigrate">Setup PostgreSQL and use Prisma Migrate</h2>
<p>Navigate to <strong>Resources</strong> tab on Heroku and search for the <strong>Heroku Postgres</strong> addon.</p>
<div shortcode="figure" caption="Add Heroku Postgres addon">

![Add Heroku Postgres addon](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/add-heroku-postgres-addon.png)

</div>
<p>We select a plan for our Postgres database, we start with the <strong>Hobby Dev - Free</strong> plan and click <strong>Provision</strong>. We can upgrade the database plan later at anytime.</p>
<div shortcode="figure" caption="Select Postgres plan">

![Select Postgres plan](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/select-postgres-plan.png)

</div>
<p>Our database has been setup and it appears in the addon list.</p>
<div shortcode="figure" caption="Open Postgres Dashboard">

![Open Postgres Dashboard](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/open-postgres-dashboard.png)

</div>
<p>To connect Prisma to the database, we need to provide the database connection URL found in the <strong>Settings</strong> of our database. Select <strong>Heroku Postgres</strong> and switch to the <strong>Settings</strong> tab and <strong>View Credentials‚Ä¶</strong>. Copy the whole <strong>URI</strong> starting with <code>postgres://</code>.</p>
<div shortcode="figure" caption="View Postgres Credentials">

![View Postgres Credentials](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/view-postgres-credentials.png)

</div>
<p><a href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/prisma-schema-file#using-environment-variables">.env</a> file support is included in Prisma 2.0. Hence, we provide the database connection URL as the environment variable <code>DATABASE_URL</code>.</p>
<div shortcode="code" tabs="schema.prisma">
<pre><code class="prisma language-prisma">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
</code></pre>

</div>
<p>Paste the <strong>URI</strong> from the Heroku Postgres dashboard into the <code>prisma/.env</code> file.</p>
<div shortcode="code" tabs=".env">
<pre><code class="bash language-bash">DATABASE_URL=postgres://ytodrxnfzdnxlr:005777fd...
</code></pre>

</div>
<div shortcode="note" type="warn">

Do not commit `.env` files into version control.

</div>
<p>Right now our database is empty and has no tables.</p>
<div shortcode="code" tabs="schema.prisma">
<pre><code class="prisma language-prisma">datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model NationalPark {
  id      Int     @id @default(autoincrement())
  name    String
  country Country @relation(fields: [countryId], references: [id])
  countryId Int
}

model Country {
  id   Int    @id @default(autoincrement())
  name String @unique
  parks NationalPark[]
}
</code></pre>

</div>
<p>Let's use <a href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-migrate">Prisma Migrate</a> to save and apply our migrations for the following schema.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npx prisma migrate dev
</code></pre>

</div>
<p>We can use <a href="https://github.com/prisma/studio">Prisma Studio</a> to view if our migration was successful. Run and open studio at <a href="http://localhost:5555">http://localhost:5555</a>.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npx prisma studio
</code></pre>

</div>
<div shortcode="figure" caption="Prisma Studio with NationalPark and Country Table">

![Prisma Studio with NationalPark and Country Table](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/prisma-studio-after-migration.png)

</div>
<p>Our migration was successful üéâ
We see the <strong>NationalPark</strong> and <strong>Country</strong> table was created in our database. We can use Prisma Studio to create our test data, start creating a new <strong>Country</strong> and then new <strong>NationalPark</strong>s as they require a connection to a country.</p>
<p>Since we have our database ready, we create two REST endpoints to query all <strong>NationalPark</strong>s and to create a new <strong>NationalPark</strong> in our Nest application.</p>
<h2 id="prismacrudoperationsinnest">Prisma CRUD operations in Nest</h2>
<p>Before we implement our CRUD operations in Nest, we need to generate a new <code>PrismaClient</code> whenever we make a change to our <code>schema.prisma</code> or our <code>.env</code> file. Run <code>npx prisma generate</code> and now we have access to the <a href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud">CRUD</a> operations of our models.</p>
<div shortcode="figure" caption="Prisma Client CRUD operations">

![Prisma Client CRUD operations](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/prisma-client-crud.png)

</div>
<h3 id="findmanynationalparks">Find Many National Parks</h3>
<p>We setup the <code>GET</code> endpoint for all <strong>NationalPark</strong>s at <code>/nationalParks</code>.</p>
<div shortcode="code" tabs="app.controller.ts">
<pre><code class="typescript language-typescript">import { Controller, Get } from '@nestjs/common';
import { PrismaService } from './prisma/prisma.service';

@Controller()
export class AppController {
  constructor(private readonly prisma: PrismaService) {}

  @Get('nationalParks')
  getNationalParks() {
    return this.prisma.nationalPark.findMany();
  }
}
</code></pre>

</div>
<p>Start the Nest app locally in dev mode <code>npm run start:dev</code> and try the request at <a href="http://localhost:3000/nationalParks">http://localhost:3000/nationalParks</a>.</p>
<div shortcode="figure" caption="Query all National Parks without Country">

![Query all National Parks without Country](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/query-national-parks-without-country-dev.png)

</div>
<p>I have added one national park via Prisma Studio, but we don't see the <strong>Country</strong> in the response. To return the countries in the national park response we <a href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/field-selection#include">include</a> country in the <code>findMany()</code> query using the <code>include</code> keyword.</p>
<div shortcode="code" tabs="app.controller.ts">
<pre><code class="typescript language-typescript">@Get('nationalParks')
getNationalParks() {
  return this.prisma.nationalPark.findMany({ include: { country: true } });
}
</code></pre>

</div>
<div shortcode="figure" caption="Query all National Parks with Country">

![Query all National Parks with Country](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/query-national-parks-dev.png)

</div>
<p>Awesome, our response now includes <strong>Country</strong>.</p>
<h3 id="createnewnationalpark">Create New National Park</h3>
<p>We can query our national parks, but we also want to add new national parks. Create the <code>NationalParkDto</code> class with the two properties <code>name</code> for the national park and <code>country</code> as the country name.</p>
<div shortcode="code" tabs="TS">
<pre><code class="typescript language-typescript">export class NationalParkDto {
  name: string;
  country: string;
}
</code></pre>

</div>
<p>We use this DTO class in the <code>POST</code> endpoint for creating a new national park.</p>
<div shortcode="code" tabs="app.controller.ts">
<pre><code class="typescript language-typescript">@Post('nationalPark')
createNationalPark(@Body() nationalParkDto: NationalParkDto) {
}
</code></pre>

</div>
<p>As we need a country <code>id</code> to connect to a national park we use <code>prisma.country.findOne</code> to see if this country already exists in our database. Use <code>async/await</code> to find the country as <code>PrismaClient</code> CRUD operations always return <code>Promise</code>'s.</p>
<div shortcode="code" tabs="app.controller.ts">
<pre><code class="typescript language-typescript">@Post('nationalPark')
async createNationalPark(@Body() nationalParkDto: NationalParkDto) {
  const country = await this.prisma.country.findOne({
    where: { name: nationalParkDto.country },
  });

  if (country) {
    // create national park and connect country
    });
  } else {
    // create national park and create country
  }
}
</code></pre>

</div>
<p>When we create our national park we have two options for how to create the connection to a country. If the country exists we use <code>connect</code> using the country id <code>country: { connect: { id: country.id } }</code>. Otherwise we <code>create</code> the country alongside the national park <code>country: { create: { name: nationalParkDto.country } }</code>. Let's also return the created <strong>NationalPark</strong> including the <strong>Country</strong> in our response. Our <code>POST</code> endpoint looks like this:</p>
<div shortcode="code" tabs="app.controller.ts">
<pre><code class="typescript language-typescript">@Post('nationalPark')
async createNationalPark(@Body() nationalParkDto: NationalParkDto) {
  const country = await this.prisma.country.findOne({
    where: { name: nationalParkDto.country },
  });

  if (country) {
    return this.prisma.nationalPark.create({
      data: {
        name: nationalParkDto.name,
        country: { connect: { id: country.id } },
      },
      include: { country: true },
    });
  } else {
    return this.prisma.nationalPark.create({
      data: {
        name: nationalParkDto.name,
        country: { create: { name: nationalParkDto.country } },
      },
      include: { country: true },
    });
  }
}
</code></pre>

</div>
<p>Yeah! üéâ The request works locally.</p>
<div shortcode="figure" caption="Create new National Park">

![Create new National Park](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/new-national-park-dev.png)

</div>
<p>We are ready to push our Nest application to Heroku again to expose the two new REST endpoints.</p>
<h3 id="pushtoherokuandtestnewendpoints">Push to Heroku and test new Endpoints</h3>
<p>Run <code>git push heroku master</code> in your Nest application and wait for the build to succeed. Also, we need to see if the environment variable <code>DATABASE_URL</code> is added to the Heroku app. Head over to the <strong>Settings</strong> tab and click on <strong>Reveal Config Vars</strong>. <code>DATABASE_URL</code> has already been added when we installed the <strong>Heroku Postgres</strong> addon. If you like to change your database you can update the URL here.</p>
<div shortcode="figure" caption="DATABASE_URL environment variable on Heroku">

![DATABASE_URL environment variable on Heroku](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/heroku-config-vars.png)

</div>
<p>Our new endpoints have been successfully deployed. Time to test it out <a href="https://nestjs-prisma-heroku.herokuapp.com/nationalParks">https://nestjs-prisma-heroku.herokuapp.com/nationalParks</a>.</p>
<div shortcode="figure" caption="Query all National Parks with Country on Heroku">

![Query all National Parks with Country on Heroku](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/query-national-parks-heroku.png)

</div>
<div shortcode="figure" caption="Create new National Park on Heroku">

![Create new National Park on Heroku](assets/img/blog/deploy-nestjs-with-prisma-to-heroku/optimized/new-national-park-heroku.png)

</div>
<p>To wrap up, we have successfully deployed üöÄ our Nest application üòª on Heroku and connected Prisma to a PostgreSQL database.</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to query your database using Prisma with NestJS]]></title>
        <id>/blog/how-to-connect-nestjs-with-prisma</id>
        <link href="https://notiz.dev/blog/how-to-connect-nestjs-with-prisma"/>
        <updated>2021-06-17T10:50:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how to setup a database with Prisma 2.0 and query data using NestJS.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://prisma.io">Prisma</a> is a toolkit for modeling, querying and migrating a <a href="https://www.prisma.io/docs/reference/database-reference/supported-databases">database</a>. <a href="https://github.com/prisma/prisma">Prisma 2.0</a> is rewritten with Rust, read more about the recent <a href="https://www.prisma.io/blog/announcing-prisma-2-n0v98rzc8br1">release</a> üéâ.</p>
<p><a href="https://nestjs.com">NestJS</a> is a popular typescript server-side application framework. It is heavily influenced by Angular's architecture and enables to create a REST and <a href="https://graphql.org">GraphQL</a> backend.</p>
<p>This guide shows you how to setup a NestJS application querying data from a SQLite database using Prisma 2.0.</p>
<h2 id="tldr">TL;DR</h2>
<p>Add Prisma to a Nest application and generate a <code>PrismaClient</code>. Create a Nest <code>PrismaModule</code> and <code>PrismaService</code> which extends <code>PrismaClient</code> and handles the connection using Nest lifecycle events. Inject <code>PrismaService</code> into REST controllers or GraphQL resolvers to query your data models.</p>
<p>Or use the <a href="/blog/nestjs-prisma-schematics">NestJS Prisma Schematics</a> to automatically setup Prisma in your NestJS application and start defining your Prisma Schema.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">nest add nestjs-prisma
</code></pre>

</div>
<h2 id="step1startanewnestjsapplication">Step 1: Start a new NestJS application</h2>
<p>Generate a new Nest application or skip to the next step if you follow along with an existing Nest project.</p>
<p>To generate a new Nest application use the nest cli:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm i -g @nestjs/cli
nest new project-name
</code></pre>

</div>
<p>Change your directory into the newly created Nest application and open up your preferred IDE.</p>
<h2 id="step2addprisma20">Step 2: Add Prisma 2.0</h2>
<p><a href="https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project-typescript-postgres">Add</a> Prisma 2.0, initialize Prisma Schema and install <a href="https://www.prisma.io/docs/concepts/components/prisma-client">Prisma Client</a> to your Nest application.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npm install prisma --save-dev
npx prisma init

npm install @prisma/client
</code></pre>

</div>
<h2 id="step3updateprismadatasource">Step 3: Update Prisma datasource</h2>
<p>In this guide you are connecting to a SQLite database. Update the <code>provider</code> in the <code>prisma/schema.prisma</code> to <code>sqlite</code> and change the <code>url</code> environment to <code>file:./dev.db</code>. <a href="https://www.prisma.io/docs/concepts/components/prisma-migrate">Prisma Migrate</a> will create a SQLite database at <code>prisma/dev.db</code>.</p>
<p>The <code>schema.prisma</code> should look like:</p>
<div shortcode="code" tabs="schema.prisma">
<pre><code class="prisma language-prisma">datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}
</code></pre>

</div>
<h2 id="step4firstprismamodel">Step 4: First Prisma model</h2>
<p>Now add a model for the database. A simple <code>User</code> model looks like:</p>
<div shortcode="code" tabs="schema.prisma">
<pre><code class="prisma language-prisma">model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
</code></pre>

</div>
<p>Add the above model to <code>schema.prisma</code> below the generator section.</p>
<p>For more complex models check out Prisma's <a href="https://www.prisma.io/docs/concepts/components/prisma-schema/data-model">data modeling</a> definition.</p>
<h2 id="step5createsqlitedatabasewithmigrate">Step 5: Create SQLite database with Migrate</h2>
<p>Create your first database migration using the <a href="https://www.prisma.io/docs/concepts/components/prisma-migrate">Prisma Migrate</a>. To use Migrate during development use the new command called:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npx prisma migrate dev
</code></pre>

</div>
<p>This creates a <code>migration.sql</code> file containing changes you made to the <code>schema.prisma</code>, updates the database schema and generates a new Prisma Client.</p>
<p>Prisma Migrate has been released as stable with <a href="https://github.com/prisma/prisma/releases/tag/2.19.0">v2.19</a>. Upgrade to the latest Prisma version and you can use the following migrate commands.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash"># since v2.19
npx prisma migrate &lt;COMMAND&gt;

npx prisma migrate dev
npx prisma migrate reset
npx prisma migrate deploy
npx prisma migrate resolve
npx prisma migrate status
</code></pre>

</div>
<div shortcode="note">

[Hassle-Free Database Migrations with Prisma Migrate](https://www.prisma.io/blog/prisma-migrate-ga-b5eno5g08d0b) is highly recommended üöÄ for more information about the stable release of Prisma Migrate. 

</div>
<h2 id="step6generateprismaclient">Step 6: Generate PrismaClient</h2>
<p>For each change you make to the data model of <code>schema.prisma</code>, you need to generate the <code>PrismaClient</code> again.</p>
<p>Run the following command to generate a new <code>PrismaClient</code> which contains the <a href="https://www.prisma.io/docs/concepts/components/prisma-client/crud">CRUD</a> operations for the new <code>User</code> model:</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">npx prisma generate
</code></pre>

</div>
<div shortcode="note">

If you run `npx prisma migrate dev` the client will be generated automatically after performing the migration.

</div>
<h2 id="step7createanestmoduleandserviceforprismaclient">Step 7: Create a Nest Module and Service for PrismaClient</h2>
<p>SQLite database is setup and a <code>User</code> model is defined with Prisma. Now its time to prepare our NestJS application to query the database using <code>PrismaClient</code>.</p>
<p>First, generate a Nest module and service called <code>prisma</code> via the NestJS CLI.</p>
<div shortcode="code" tabs="BASH">
<pre><code class="bash language-bash">nest generate module prisma
nest generate service prisma
</code></pre>

</div>
<p>Open the <code>PrismaModule</code> and add <code>PrismaService</code> to the <code>exports</code> list to be available for dependency injection. Add the <code>PrismaModule</code> to the <code>imports</code> list of your modules which need to use the <code>PrismaService</code>.</p>
<div shortcode="code" tabs="prisma.module.ts">
<pre><code class="ts language-ts">import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService] // üëà export PrismaService for DI
})
export class PrismaModule {}
</code></pre>

</div>
<p>Open <code>PrismaService</code> and extend it with the <code>PrismaClient</code></p>
<div shortcode="code" tabs="prisma.service.ts">
<pre><code class="ts language-ts">import { Injectable } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient {
  constructor() {
    super();
  }
}
</code></pre>

</div>
<p><code>PrismaClient</code> has two different ways to start a connection to your database: <strong>lazy</strong> or <strong>explicit</strong>.
After you run your <strong>first</strong> query, <code>PrismaClient</code> automatically creates a connection (<strong>lazy</strong>) to the database. If needed rapid response after application start, you can <strong>explicitly</strong> start or stop a connection using <code>$connect()</code> and <code>$disconnect()</code>.</p>
<p>Use the Nest <a href="https://docs.nestjs.com/fundamentals/lifecycle-events">Lifecycle Events</a> <code>OnModuleInit</code> and <code>OnModuleDestroy</code> to take care of starting <strong>explicit</strong> the connection for you. Implement <code>OnModuleInit</code> and <code>OnModuleDestroy</code> in your <code>PrismaService</code>.</p>
<p>The <code>PrismaService</code> with the <strong>explicit</strong> connection and lifecycle events looks like:</p>
<div shortcode="code" tabs="prisma.service.ts">
<pre><code class="typescript language-typescript">import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient
  implements OnModuleInit, OnModuleDestroy {
  constructor() {
    super();
  }

  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
</code></pre>

</div>
<h2 id="step8querydatamodel">Step 8: Query data model</h2>
<p>Now you can inject the <code>PrismaService</code> into any REST controller, GraphQL resolver or service to query our data model. Make sure you add <code>PrismaModule</code> to the <code>imports</code> list of the module. Inject it into a controller and create REST endpoints querying and creating <code>User</code> models.</p>
<p>Note you are directly accessing the type-safe generated API from the <code>PrismaClient</code> through <code>PrismaService</code>.</p>
<div shortcode="code" tabs="app.controller.ts">
<pre><code class="typescript language-typescript">import { Controller, Get, Param, Post, Body } from '@nestjs/common';
import { AppService } from './app.service';
import { PrismaService } from './prisma/prisma.service';
import { CreateUserDto } from './create-user.dto';

@Controller()
export class AppController {
  constructor(
    private readonly appService: AppService,
    private readonly prisma: PrismaService
  ) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('users')
  async users() {
    return await this.prisma.user.findMany();
  }

  @Get('users/:id')
  async user(@Param('id') id: string) {
    return await this.prisma.user.findOne({ where: { id: +id } });
  }

  @Post('user')
  async addUser(@Body() createUserDto: CreateUserDto) {
    return await this.prisma.user.create({ data: createUserDto });
  }
}
</code></pre>

</div>
<p>Now its time to continue updating your data model, generating <code>PrismaClient</code> and adding queries to your Nest application.</p>
<p>Checkout <a href="https://github.com/notiz-dev/nestjs-prisma-starter">nestjs-prisma-starter</a> to get started quickly with Nest and Prisma, if you like it leave a ‚≠ê.</p>
<p><div shortcode="repo" repo="notiz-dev/nestjs-prisma-starter">&lt;/div</p>]]></content>
        <author>
            <name>Marc Stammerjohann</name>
        </author>
        <contributor>
            <name>marc-stammerjohann</name>
        </contributor>
    </entry>
</feed>